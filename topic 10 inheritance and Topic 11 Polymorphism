```
================================================================================
                    TOPIC 10: INHERITANCE IN JAVA
================================================================================

What is Inheritance?
--------------------
Inheritance is a mechanism where a new class (child/subclass) acquires the
properties and behaviors of an existing class (parent/superclass). It
represents an "IS-A" relationship between classes.

Real-World Analogy:
-------------------
- Parent: Animal (has properties like name, age; behaviors like eat, sleep)
- Child: Dog (inherits from Animal, adds its own property like breed, behavior like bark)

A Dog IS-A Animal. Dog inherits all characteristics of Animal and adds its own.


Visual Representation:
----------------------
        +------------------+
        |      Animal      |    <-- Parent/Superclass/Base Class
        +------------------+
        | - name           |
        | - age            |
        +------------------+
        | + eat()          |
        | + sleep()        |
        +------------------+
                ^
                | extends (inherits)
                |
        +------------------+
        |       Dog        |    <-- Child/Subclass/Derived Class
        +------------------+
        | - breed          |    <-- Own property
        +------------------+
        | + bark()         |    <-- Own method
        | + eat()          |    <-- Can override parent method
        +------------------+


Key Terminology:
----------------
+----------------------+-------------------------------------------------------+
| Term                 | Description                                           |
+----------------------+-------------------------------------------------------+
| Parent Class         | The class being inherited from (also: superclass,     |
|                      | base class)                                           |
| Child Class          | The class that inherits (also: subclass, derived      |
|                      | class)                                                |
| extends              | Keyword used to inherit from a class                  |
| super                | Keyword to refer to parent class                      |
| Override             | Redefining parent method in child class               |
| IS-A                 | Relationship between child and parent                 |
+----------------------+-------------------------------------------------------+


Why Use Inheritance?
--------------------
1. Code Reusability: Write once in parent, use in all children
2. Method Overriding: Customize inherited behavior
3. Polymorphism: Treat different objects uniformly
4. Logical Organization: Create hierarchical class structure
5. Maintainability: Changes in parent reflect in all children


Why Important for Automation?
-----------------------------
- Base Test Class: Common setup/teardown for all tests
- Page Object Base: Shared methods for all page objects
- Driver Management: Inherit WebDriver handling
- Report Generation: Common reporting methods
- Utility Inheritance: Shared helper methods
- Framework Design: Hierarchical test structure


================================================================================
                    1. BASIC INHERITANCE SYNTAX
================================================================================

Syntax:
-------
class ParentClass {
    // parent members
}

class ChildClass extends ParentClass {
    // child members
    // inherits parent members
}


--------------------------------------------------------------------------------
EXAMPLE 1: Basic Inheritance
--------------------------------------------------------------------------------

// Parent Class
class Animal {
    
    // Fields
    String name;
    int age;
    
    // Constructor
    public Animal() {
        System.out.println("[Animal] Default constructor called");
    }
    
    // Methods
    public void eat() {
        System.out.println(name + " is eating.");
    }
    
    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

// Child Class
class Dog extends Animal {
    
    // Additional field specific to Dog
    String breed;
    
    // Constructor
    public Dog() {
        System.out.println("[Dog] Default constructor called");
    }
    
    // Additional method specific to Dog
    public void bark() {
        System.out.println(name + " is barking: Woof! Woof!");
    }
    
    public void fetch() {
        System.out.println(name + " is fetching the ball.");
    }
}

// Another Child Class
class Cat extends Animal {
    
    String color;
    
    public Cat() {
        System.out.println("[Cat] Default constructor called");
    }
    
    public void meow() {
        System.out.println(name + " is meowing: Meow!");
    }
    
    public void climb() {
        System.out.println(name + " is climbing the tree.");
    }
}

// Demo Class
public class InheritanceBasicDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Basic Inheritance Demo ===\n");
        
        // Create Dog object
        System.out.println("--- Creating Dog Object ---");
        Dog dog = new Dog();
        
        // Access inherited fields
        dog.name = "Buddy";
        dog.age = 3;
        dog.breed = "Golden Retriever";
        
        System.out.println();
        
        // Use inherited methods
        System.out.println("--- Using Inherited Methods ---");
        dog.displayInfo();
        dog.eat();
        dog.sleep();
        
        // Use Dog-specific methods
        System.out.println("\n--- Using Dog-Specific Methods ---");
        dog.bark();
        dog.fetch();
        System.out.println("Breed: " + dog.breed);
        
        System.out.println("\n" + "=".repeat(40) + "\n");
        
        // Create Cat object
        System.out.println("--- Creating Cat Object ---");
        Cat cat = new Cat();
        cat.name = "Whiskers";
        cat.age = 2;
        cat.color = "Orange";
        
        System.out.println();
        
        System.out.println("--- Using Cat Methods ---");
        cat.displayInfo();
        cat.eat();
        cat.meow();
        cat.climb();
        System.out.println("Color: " + cat.color);
    }
}

OUTPUT:
-------
=== Basic Inheritance Demo ===

--- Creating Dog Object ---
[Animal] Default constructor called
[Dog] Default constructor called

--- Using Inherited Methods ---
Name: Buddy, Age: 3
Buddy is eating.
Buddy is sleeping.

--- Using Dog-Specific Methods ---
Buddy is barking: Woof! Woof!
Buddy is fetching the ball.
Breed: Golden Retriever

========================================

--- Creating Cat Object ---
[Animal] Default constructor called
[Cat] Default constructor called

--- Using Cat Methods ---
Name: Whiskers, Age: 2
Whiskers is eating.
Whiskers is meowing: Meow!
Whiskers is climbing the tree.
Color: Orange


================================================================================
                    2. TYPES OF INHERITANCE IN JAVA
================================================================================

Java supports the following types of inheritance:

+---------------------+----------------------------------------------------------+
| Type                | Description                                              |
+---------------------+----------------------------------------------------------+
| Single              | One child inherits from one parent                       |
| Multilevel          | Chain of inheritance (A -> B -> C)                       |
| Hierarchical        | Multiple children inherit from one parent                |
+---------------------+----------------------------------------------------------+

NOT Supported in Java (with classes):
+---------------------+----------------------------------------------------------+
| Multiple            | One child inherits from multiple parents (NOT ALLOWED)   |
| Hybrid              | Combination of multiple inheritance types                |
+---------------------+----------------------------------------------------------+

Note: Multiple inheritance is achieved through interfaces (covered later).


Visual Representation:
----------------------

1. SINGLE INHERITANCE:
   
   +--------+
   | Parent |
   +--------+
       ^
       |
   +--------+
   | Child  |
   +--------+


2. MULTILEVEL INHERITANCE:

   +--------------+
   | GrandParent  |
   +--------------+
         ^
         |
   +--------------+
   |    Parent    |
   +--------------+
         ^
         |
   +--------------+
   |    Child     |
   +--------------+


3. HIERARCHICAL INHERITANCE:

         +--------+
         | Parent |
         +--------+
          ^  ^  ^
         /   |   \
        /    |    \
   +------+ +------+ +------+
   |Child1| |Child2| |Child3|
   +------+ +------+ +------+


4. MULTIPLE INHERITANCE (NOT ALLOWED with classes):

   +--------+   +--------+
   |Parent1 |   |Parent2 |
   +--------+   +--------+
        ^          ^
         \        /
          \      /
         +--------+
         | Child  |    <-- NOT ALLOWED in Java!
         +--------+


--------------------------------------------------------------------------------
EXAMPLE 2: Types of Inheritance
--------------------------------------------------------------------------------

// ============================================================
// SINGLE INHERITANCE
// ============================================================

class Vehicle {
    String brand;
    int year;
    
    public void start() {
        System.out.println("Vehicle starting...");
    }
    
    public void stop() {
        System.out.println("Vehicle stopping...");
    }
}

class Car extends Vehicle {
    int numberOfDoors;
    
    public void honk() {
        System.out.println("Car honking: Beep! Beep!");
    }
}


// ============================================================
// MULTILEVEL INHERITANCE
// ============================================================

class LivingThing {
    boolean isAlive = true;
    
    public void breathe() {
        System.out.println("Breathing...");
    }
}

class Human extends LivingThing {
    String name;
    
    public void speak() {
        System.out.println(name + " is speaking.");
    }
}

class Employee extends Human {
    String employeeId;
    String department;
    
    public void work() {
        System.out.println(name + " (ID: " + employeeId + ") is working in " + department);
    }
}


// ============================================================
// HIERARCHICAL INHERITANCE
// ============================================================

class Shape {
    String color;
    
    public void draw() {
        System.out.println("Drawing a shape...");
    }
    
    public double getArea() {
        return 0;
    }
}

class Circle extends Shape {
    double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a circle with radius " + radius);
    }
}

class Rectangle extends Shape {
    double length;
    double width;
    
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    public double getArea() {
        return length * width;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a rectangle " + length + " x " + width);
    }
}

class Triangle extends Shape {
    double base;
    double height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return 0.5 * base * height;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a triangle with base " + base + " and height " + height);
    }
}


// Demo Class
public class InheritanceTypesDemo {
    public static void main(String[] args) {
        
        // ========== SINGLE INHERITANCE ==========
        System.out.println("=== SINGLE INHERITANCE ===\n");
        
        Car car = new Car();
        car.brand = "Toyota";
        car.year = 2023;
        car.numberOfDoors = 4;
        
        System.out.println("Brand: " + car.brand + ", Year: " + car.year);
        System.out.println("Doors: " + car.numberOfDoors);
        car.start();
        car.honk();
        car.stop();
        
        
        // ========== MULTILEVEL INHERITANCE ==========
        System.out.println("\n=== MULTILEVEL INHERITANCE ===\n");
        
        Employee emp = new Employee();
        emp.name = "John Doe";
        emp.employeeId = "EMP001";
        emp.department = "Engineering";
        
        // Methods from all levels
        System.out.println("Is Alive: " + emp.isAlive);    // From LivingThing
        emp.breathe();                                       // From LivingThing
        emp.speak();                                         // From Human
        emp.work();                                          // From Employee
        
        
        // ========== HIERARCHICAL INHERITANCE ==========
        System.out.println("\n=== HIERARCHICAL INHERITANCE ===\n");
        
        Circle circle = new Circle(5);
        circle.color = "Red";
        
        Rectangle rectangle = new Rectangle(4, 6);
        rectangle.color = "Blue";
        
        Triangle triangle = new Triangle(3, 4);
        triangle.color = "Green";
        
        // All shapes share parent class but have different implementations
        System.out.println("Circle:");
        circle.draw();
        System.out.println("Area: " + String.format("%.2f", circle.getArea()));
        System.out.println("Color: " + circle.color);
        
        System.out.println("\nRectangle:");
        rectangle.draw();
        System.out.println("Area: " + rectangle.getArea());
        System.out.println("Color: " + rectangle.color);
        
        System.out.println("\nTriangle:");
        triangle.draw();
        System.out.println("Area: " + triangle.getArea());
        System.out.println("Color: " + triangle.color);
    }
}

OUTPUT:
-------
=== SINGLE INHERITANCE ===

Brand: Toyota, Year: 2023
Doors: 4
Vehicle starting...
Car honking: Beep! Beep!
Vehicle stopping...

=== MULTILEVEL INHERITANCE ===

Is Alive: true
Breathing...
John Doe is speaking.
John Doe (ID: EMP001) is working in Engineering

=== HIERARCHICAL INHERITANCE ===

Circle:
Drawing a circle with radius 5.0
Area: 78.54
Color: Red

Rectangle:
Drawing a rectangle 4.0 x 6.0
Area: 24.0
Color: Blue

Triangle:
Drawing a triangle with base 3.0 and height 4.0
Area: 6.0
Color: Green


================================================================================
                    3. 'SUPER' KEYWORD
================================================================================

The 'super' keyword is used to refer to the parent class. It can be used to:
1. Access parent class fields
2. Call parent class methods
3. Call parent class constructor


Uses of 'super':
----------------
+----------------------+-------------------------------------------------------+
| Usage                | Syntax                                                |
+----------------------+-------------------------------------------------------+
| Access parent field  | super.fieldName                                       |
| Call parent method   | super.methodName()                                    |
| Call parent const.   | super() or super(arguments)                           |
+----------------------+-------------------------------------------------------+


--------------------------------------------------------------------------------
EXAMPLE 3: Using 'super' Keyword
--------------------------------------------------------------------------------

// Parent Class
class Person {
    
    String name;
    int age;
    String city;
    
    // Constructor
    public Person() {
        System.out.println("[Person] No-arg constructor called");
        this.name = "Unknown";
        this.age = 0;
        this.city = "Unknown";
    }
    
    public Person(String name, int age) {
        System.out.println("[Person] Two-arg constructor called");
        this.name = name;
        this.age = age;
        this.city = "Unknown";
    }
    
    public Person(String name, int age, String city) {
        System.out.println("[Person] Three-arg constructor called");
        this.name = name;
        this.age = age;
        this.city = city;
    }
    
    // Methods
    public void displayInfo() {
        System.out.println("Person Info:");
        System.out.println("  Name: " + name);
        System.out.println("  Age: " + age);
        System.out.println("  City: " + city);
    }
    
    public void greet() {
        System.out.println("Hello, I am " + name);
    }
}

// Child Class
class Student extends Person {
    
    String studentId;
    String course;
    double gpa;
    String city;    // Same name as parent field (shadowing)
    
    // ========== USE 1: Call parent constructor using super() ==========
    
    public Student() {
        super();    // Calls Person() - must be first statement
        System.out.println("[Student] No-arg constructor called");
        this.studentId = "Unknown";
        this.course = "Unknown";
    }
    
    public Student(String name, int age, String studentId, String course) {
        super(name, age);    // Calls Person(String, int)
        System.out.println("[Student] Four-arg constructor called");
        this.studentId = studentId;
        this.course = course;
    }
    
    public Student(String name, int age, String city, String studentId, String course, double gpa) {
        super(name, age, city);    // Calls Person(String, int, String)
        System.out.println("[Student] Six-arg constructor called");
        this.studentId = studentId;
        this.course = course;
        this.gpa = gpa;
        this.city = "Student City: " + city;    // Different value for shadowed field
    }
    
    // ========== USE 2: Access parent field using super.fieldName ==========
    
    public void showCities() {
        System.out.println("Parent city (super.city): " + super.city);
        System.out.println("Student city (this.city): " + this.city);
    }
    
    // ========== USE 3: Call parent method using super.methodName() ==========
    
    @Override
    public void displayInfo() {
        // Call parent's displayInfo first
        super.displayInfo();
        
        // Then add student-specific info
        System.out.println("Student Info:");
        System.out.println("  Student ID: " + studentId);
        System.out.println("  Course: " + course);
        System.out.println("  GPA: " + gpa);
    }
    
    @Override
    public void greet() {
        super.greet();    // Call parent's greet
        System.out.println("I am studying " + course);
    }
    
    public void study() {
        System.out.println(name + " is studying " + course);
    }
}

// Demo Class
public class SuperKeywordDemo {
    public static void main(String[] args) {
        
        System.out.println("=== 'super' Keyword Demo ===\n");
        
        // Test 1: super() calling parent constructor
        System.out.println("--- Test 1: super() Constructor Call ---");
        Student s1 = new Student();
        System.out.println();
        
        // Test 2: super(args) calling parameterized parent constructor
        System.out.println("--- Test 2: super(args) Constructor Call ---");
        Student s2 = new Student("Alice", 20, "S001", "Computer Science");
        System.out.println();
        
        // Test 3: Full constructor chain
        System.out.println("--- Test 3: Full Constructor Chain ---");
        Student s3 = new Student("Bob", 22, "New York", "S002", "Engineering", 3.8);
        System.out.println();
        
        // Test 4: super.fieldName - accessing parent field
        System.out.println("--- Test 4: super.fieldName ---");
        s3.showCities();
        System.out.println();
        
        // Test 5: super.methodName() - calling parent method
        System.out.println("--- Test 5: super.methodName() ---");
        System.out.println("Calling overridden displayInfo():");
        s3.displayInfo();
        System.out.println();
        
        System.out.println("Calling overridden greet():");
        s3.greet();
    }
}

OUTPUT:
-------
=== 'super' Keyword Demo ===

--- Test 1: super() Constructor Call ---
[Person] No-arg constructor called
[Student] No-arg constructor called

--- Test 2: super(args) Constructor Call ---
[Person] Two-arg constructor called
[Student] Four-arg constructor called

--- Test 3: Full Constructor Chain ---
[Person] Three-arg constructor called
[Student] Six-arg constructor called

--- Test 4: super.fieldName ---
Parent city (super.city): New York
Student city (this.city): Student City: New York

--- Test 5: super.methodName() ---
Calling overridden displayInfo():
Person Info:
  Name: Bob
  Age: 22
  City: New York
Student Info:
  Student ID: S002
  Course: Engineering
  GPA: 3.8

Calling overridden greet():
Hello, I am Bob
I am studying Engineering


================================================================================
                    4. METHOD OVERRIDING
================================================================================

What is Method Overriding?
--------------------------
Method overriding occurs when a child class provides a specific implementation
for a method that is already defined in its parent class.


Rules for Method Overriding:
----------------------------
1. Method name must be the same
2. Parameter list must be the same
3. Return type must be same or covariant (subtype)
4. Access modifier cannot be more restrictive
5. Cannot override static, final, or private methods
6. Use @Override annotation (recommended)


Method Overriding vs Method Overloading:
----------------------------------------
+------------------+---------------------------+---------------------------+
| Feature          | Overriding                | Overloading               |
+------------------+---------------------------+---------------------------+
| Definition       | Same method, different    | Same name, different      |
|                  | implementation            | parameters                |
| Classes          | Parent and child          | Same class or inherited   |
| Parameters       | Must be same              | Must be different         |
| Return type      | Same or covariant         | Can be different          |
| Binding          | Runtime (dynamic)         | Compile-time (static)     |
| Keyword          | @Override                 | No keyword                |
+------------------+---------------------------+---------------------------+


--------------------------------------------------------------------------------
EXAMPLE 4: Method Overriding
--------------------------------------------------------------------------------

// Parent Class
class BankAccount {
    
    protected String accountNumber;
    protected double balance;
    protected String accountType;
    
    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
        this.accountType = "Basic";
    }
    
    // Method to be overridden
    public double calculateInterest() {
        double interestRate = 0.02;    // 2% basic interest
        return balance * interestRate;
    }
    
    // Method to be overridden
    public void withdraw(double amount) {
        if (amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: $" + amount);
            System.out.println("New Balance: $" + balance);
        } else {
            System.out.println("Insufficient balance!");
        }
    }
    
    // Method to be overridden
    public String getAccountDetails() {
        return "Account: " + accountNumber + ", Type: " + accountType + ", Balance: $" + balance;
    }
    
    // Final method - cannot be overridden
    public final String getAccountNumber() {
        return accountNumber;
    }
    
    public void displayBalance() {
        System.out.println("Current Balance: $" + balance);
    }
}

// Child Class 1
class SavingsAccount extends BankAccount {
    
    private double minimumBalance;
    
    public SavingsAccount(String accountNumber, double balance, double minimumBalance) {
        super(accountNumber, balance);
        this.accountType = "Savings";
        this.minimumBalance = minimumBalance;
    }
    
    // Override: Different interest rate
    @Override
    public double calculateInterest() {
        double interestRate = 0.04;    // 4% for savings
        return balance * interestRate;
    }
    
    // Override: Check minimum balance
    @Override
    public void withdraw(double amount) {
        if (balance - amount >= minimumBalance) {
            balance -= amount;
            System.out.println("Withdrawn: $" + amount);
            System.out.println("New Balance: $" + balance);
        } else {
            System.out.println("Cannot withdraw! Minimum balance of $" + minimumBalance + " required.");
        }
    }
    
    // Override: Add minimum balance info
    @Override
    public String getAccountDetails() {
        return super.getAccountDetails() + ", Min Balance: $" + minimumBalance;
    }
}

// Child Class 2
class CurrentAccount extends BankAccount {
    
    private double overdraftLimit;
    
    public CurrentAccount(String accountNumber, double balance, double overdraftLimit) {
        super(accountNumber, balance);
        this.accountType = "Current";
        this.overdraftLimit = overdraftLimit;
    }
    
    // Override: No interest for current account
    @Override
    public double calculateInterest() {
        return 0;    // No interest
    }
    
    // Override: Allow overdraft
    @Override
    public void withdraw(double amount) {
        if (amount <= balance + overdraftLimit) {
            balance -= amount;
            System.out.println("Withdrawn: $" + amount);
            System.out.println("New Balance: $" + balance);
            if (balance < 0) {
                System.out.println("WARNING: Account in overdraft!");
            }
        } else {
            System.out.println("Cannot withdraw! Exceeds overdraft limit.");
        }
    }
    
    // Override: Add overdraft info
    @Override
    public String getAccountDetails() {
        return super.getAccountDetails() + ", Overdraft Limit: $" + overdraftLimit;
    }
}

// Child Class 3
class FixedDepositAccount extends BankAccount {
    
    private int termMonths;
    private boolean isMatured;
    
    public FixedDepositAccount(String accountNumber, double balance, int termMonths) {
        super(accountNumber, balance);
        this.accountType = "Fixed Deposit";
        this.termMonths = termMonths;
        this.isMatured = false;
    }
    
    // Override: Higher interest based on term
    @Override
    public double calculateInterest() {
        double interestRate;
        if (termMonths >= 12) {
            interestRate = 0.07;    // 7% for 1+ year
        } else if (termMonths >= 6) {
            interestRate = 0.06;    // 6% for 6+ months
        } else {
            interestRate = 0.05;    // 5% for less than 6 months
        }
        return balance * interestRate;
    }
    
    // Override: No withdrawal before maturity
    @Override
    public void withdraw(double amount) {
        if (!isMatured) {
            System.out.println("Cannot withdraw! Fixed deposit not matured yet.");
            System.out.println("Term: " + termMonths + " months");
        } else {
            super.withdraw(amount);    // Use parent's withdraw
        }
    }
    
    // Override: Add term info
    @Override
    public String getAccountDetails() {
        return super.getAccountDetails() + ", Term: " + termMonths + " months, Matured: " + isMatured;
    }
    
    public void mature() {
        this.isMatured = true;
        System.out.println("Fixed deposit has matured!");
    }
}

// Demo Class
public class MethodOverridingDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Method Overriding Demo ===\n");
        
        // Create different account types
        BankAccount basic = new BankAccount("BASIC001", 1000);
        SavingsAccount savings = new SavingsAccount("SAV001", 5000, 500);
        CurrentAccount current = new CurrentAccount("CUR001", 3000, 1000);
        FixedDepositAccount fd = new FixedDepositAccount("FD001", 10000, 12);
        
        // Display account details
        System.out.println("--- Account Details ---");
        System.out.println(basic.getAccountDetails());
        System.out.println(savings.getAccountDetails());
        System.out.println(current.getAccountDetails());
        System.out.println(fd.getAccountDetails());
        
        // Calculate interest (different for each type)
        System.out.println("\n--- Interest Calculation (Overridden Method) ---");
        System.out.println("Basic Account Interest: $" + basic.calculateInterest());
        System.out.println("Savings Account Interest: $" + savings.calculateInterest());
        System.out.println("Current Account Interest: $" + current.calculateInterest());
        System.out.println("Fixed Deposit Interest: $" + fd.calculateInterest());
        
        // Test withdrawal (different rules for each type)
        System.out.println("\n--- Withdrawal Tests (Overridden Method) ---");
        
        System.out.println("\nSavings Account - Withdraw $4600 (would go below min balance):");
        savings.withdraw(4600);
        
        System.out.println("\nSavings Account - Withdraw $4000 (valid):");
        savings.withdraw(4000);
        
        System.out.println("\nCurrent Account - Withdraw $3500 (using overdraft):");
        current.withdraw(3500);
        
        System.out.println("\nFixed Deposit - Withdraw before maturity:");
        fd.withdraw(1000);
        
        System.out.println("\nFixed Deposit - After maturity:");
        fd.mature();
        fd.withdraw(1000);
    }
}

OUTPUT:
-------
=== Method Overriding Demo ===

--- Account Details ---
Account: BASIC001, Type: Basic, Balance: $1000.0
Account: SAV001, Type: Savings, Balance: $5000.0, Min Balance: $500.0
Account: CUR001, Type: Current, Balance: $3000.0, Overdraft Limit: $1000.0
Account: FD001, Type: Fixed Deposit, Balance: $10000.0, Term: 12 months, Matured: false

--- Interest Calculation (Overridden Method) ---
Basic Account Interest: $20.0
Savings Account Interest: $200.0
Current Account Interest: $0.0
Fixed Deposit Interest: $700.0

--- Withdrawal Tests (Overridden Method) ---

Savings Account - Withdraw $4600 (would go below min balance):
Cannot withdraw! Minimum balance of $500.0 required.

Savings Account - Withdraw $4000 (valid):
Withdrawn: $4000.0
New Balance: $1000.0

Current Account - Withdraw $3500 (using overdraft):
Withdrawn: $3500.0
New Balance: $-500.0
WARNING: Account in overdraft!

Fixed Deposit - Withdraw before maturity:
Cannot withdraw! Fixed deposit not matured yet.
Term: 12 months

Fixed Deposit - After maturity:
Fixed deposit has matured!
Withdrawn: $1000.0
New Balance: $9000.0


================================================================================
                    5. CONSTRUCTOR CHAINING
================================================================================

What is Constructor Chaining?
-----------------------------
Constructor chaining is the process of calling one constructor from another.
It happens automatically when creating child class objects.

Order of Constructor Execution:
-------------------------------
1. Parent class constructor is ALWAYS called first
2. Then child class constructor executes
3. If super() is not explicitly called, Java inserts super() automatically


Visual Representation:
----------------------
Creating Child Object:
    
    new Child()
         |
         v
    +------------------+
    | Child Constructor|
    +------------------+
         |
         | super() called first
         v
    +------------------+
    |Parent Constructor|
    +------------------+
         |
         | (If Parent has Parent)
         v
    +------------------+
    |GrandParent Const.|
    +------------------+
         |
         | Object class (implicit)
         v
    +------------------+
    | Object()         |
    +------------------+
         |
         | Return back up
         v
    Constructors complete
    in reverse order


--------------------------------------------------------------------------------
EXAMPLE 5: Constructor Chaining
--------------------------------------------------------------------------------

// GrandParent Class
class GrandParent {
    
    String familyName;
    
    public GrandParent() {
        System.out.println("1. GrandParent() - No-arg constructor");
        this.familyName = "Smith";
    }
    
    public GrandParent(String familyName) {
        System.out.println("1. GrandParent(String) - Parameterized constructor");
        this.familyName = familyName;
    }
}

// Parent Class
class Parent extends GrandParent {
    
    String firstName;
    int age;
    
    public Parent() {
        // super() is implicitly called here
        System.out.println("2. Parent() - No-arg constructor");
        this.firstName = "Unknown";
        this.age = 0;
    }
    
    public Parent(String familyName, String firstName) {
        super(familyName);    // Explicit call to parent constructor
        System.out.println("2. Parent(String, String) - Two-arg constructor");
        this.firstName = firstName;
        this.age = 0;
    }
    
    public Parent(String familyName, String firstName, int age) {
        super(familyName);
        System.out.println("2. Parent(String, String, int) - Three-arg constructor");
        this.firstName = firstName;
        this.age = age;
    }
}

// Child Class
class Child extends Parent {
    
    String schoolName;
    int grade;
    
    public Child() {
        // super() implicitly calls Parent()
        System.out.println("3. Child() - No-arg constructor");
        this.schoolName = "Unknown";
        this.grade = 0;
    }
    
    public Child(String familyName, String firstName, String schoolName) {
        super(familyName, firstName);    // Calls Parent(String, String)
        System.out.println("3. Child(String, String, String) - Three-arg constructor");
        this.schoolName = schoolName;
        this.grade = 0;
    }
    
    public Child(String familyName, String firstName, int age, String schoolName, int grade) {
        super(familyName, firstName, age);    // Calls Parent(String, String, int)
        System.out.println("3. Child(5 args) - Five-arg constructor");
        this.schoolName = schoolName;
        this.grade = grade;
    }
    
    public void displayFullInfo() {
        System.out.println("Family Name: " + familyName);
        System.out.println("First Name: " + firstName);
        System.out.println("Age: " + age);
        System.out.println("School: " + schoolName);
        System.out.println("Grade: " + grade);
    }
}

// Demo Class
public class ConstructorChainingDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Constructor Chaining Demo ===\n");
        
        // Test 1: Default constructors
        System.out.println("--- Test 1: Child() - Default Constructor Chain ---");
        Child c1 = new Child();
        System.out.println();
        c1.displayFullInfo();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Test 2: Partial parameterized constructors
        System.out.println("--- Test 2: Child(3 args) - Partial Chain ---");
        Child c2 = new Child("Johnson", "Emma", "Springfield Elementary");
        System.out.println();
        c2.displayFullInfo();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Test 3: Full parameterized constructors
        System.out.println("--- Test 3: Child(5 args) - Full Chain ---");
        Child c3 = new Child("Williams", "Oliver", 10, "Lincoln High School", 5);
        System.out.println();
        c3.displayFullInfo();
    }
}

OUTPUT:
-------
=== Constructor Chaining Demo ===

--- Test 1: Child() - Default Constructor Chain ---
1. GrandParent() - No-arg constructor
2. Parent() - No-arg constructor
3. Child() - No-arg constructor

Family Name: Smith
First Name: Unknown
Age: 0
School: Unknown
Grade: 0

==================================================

--- Test 2: Child(3 args) - Partial Chain ---
1. GrandParent(String) - Parameterized constructor
2. Parent(String, String) - Two-arg constructor
3. Child(String, String, String) - Three-arg constructor

Family Name: Johnson
First Name: Emma
Age: 0
School: Springfield Elementary
Grade: 0

==================================================

--- Test 3: Child(5 args) - Full Chain ---
1. GrandParent(String) - Parameterized constructor
2. Parent(String, String, int) - Three-arg constructor
3. Child(5 args) - Five-arg constructor

Family Name: Williams
First Name: Oliver
Age: 10
School: Lincoln High School
Grade: 5


================================================================================
                    6. WHAT IS INHERITED AND WHAT IS NOT
================================================================================

+----------------------+------------------+--------------------------------------+
| Member Type          | Inherited?       | Notes                                |
+----------------------+------------------+--------------------------------------+
| Public fields        | Yes              | Directly accessible in child         |
| Protected fields     | Yes              | Accessible in child                  |
| Default fields       | Yes*             | Only if same package                 |
| Private fields       | No               | Use getters/setters                  |
+----------------------+------------------+--------------------------------------+
| Public methods       | Yes              | Can be overridden                    |
| Protected methods    | Yes              | Can be overridden                    |
| Default methods      | Yes*             | Only if same package                 |
| Private methods      | No               | Not inherited                        |
+----------------------+------------------+--------------------------------------+
| Constructors         | No               | Use super() to call                  |
| Static members       | Not truly        | Accessed via class name              |
| Final methods        | Yes              | Cannot be overridden                 |
+----------------------+------------------+--------------------------------------+


--------------------------------------------------------------------------------
EXAMPLE 6: What Is Inherited
--------------------------------------------------------------------------------

class ParentClass {
    
    // Fields with different access modifiers
    public String publicField = "Public Field";
    protected String protectedField = "Protected Field";
    String defaultField = "Default Field";
    private String privateField = "Private Field";
    
    // Static field
    public static int staticCount = 0;
    
    // Constructor (NOT inherited)
    public ParentClass() {
        staticCount++;
        System.out.println("ParentClass constructor called");
    }
    
    // Methods with different access modifiers
    public void publicMethod() {
        System.out.println("Public method in Parent");
    }
    
    protected void protectedMethod() {
        System.out.println("Protected method in Parent");
    }
    
    void defaultMethod() {
        System.out.println("Default method in Parent");
    }
    
    private void privateMethod() {
        System.out.println("Private method in Parent");
    }
    
    // Final method (inherited but cannot be overridden)
    public final void finalMethod() {
        System.out.println("Final method in Parent - cannot be overridden");
    }
    
    // Static method
    public static void staticMethod() {
        System.out.println("Static method in Parent");
    }
    
    // Getter for private field
    public String getPrivateField() {
        return privateField;
    }
    
    // Method that uses private method
    public void callPrivateMethod() {
        privateMethod();
    }
}

class ChildClass extends ParentClass {
    
    public ChildClass() {
        // super() is implicitly called
        System.out.println("ChildClass constructor called");
    }
    
    // Override public method
    @Override
    public void publicMethod() {
        System.out.println("Public method OVERRIDDEN in Child");
    }
    
    // Override protected method
    @Override
    protected void protectedMethod() {
        System.out.println("Protected method OVERRIDDEN in Child");
    }
    
    // Cannot override final method
    // @Override
    // public void finalMethod() { }  // ERROR!
    
    // Cannot override private method (not inherited)
    // This is a NEW method, not an override
    private void privateMethod() {
        System.out.println("This is a NEW private method in Child");
    }
    
    // Method to test field access
    public void testFieldAccess() {
        System.out.println("Accessing fields from Child class:");
        System.out.println("  publicField: " + publicField);
        System.out.println("  protectedField: " + protectedField);
        System.out.println("  defaultField: " + defaultField);
        // System.out.println("  privateField: " + privateField);  // ERROR!
        System.out.println("  privateField via getter: " + getPrivateField());
    }
}

public class InheritanceAccessDemo {
    public static void main(String[] args) {
        
        System.out.println("=== What Is Inherited Demo ===\n");
        
        System.out.println("--- Creating Child Object ---");
        ChildClass child = new ChildClass();
        
        System.out.println("\n--- Testing Field Access ---");
        child.testFieldAccess();
        
        System.out.println("\n--- Testing Method Inheritance ---");
        System.out.println("Calling methods on child object:");
        
        System.out.println("\npublicMethod():");
        child.publicMethod();
        
        System.out.println("\nprotectedMethod():");
        child.protectedMethod();
        
        System.out.println("\ndefaultMethod():");
        child.defaultMethod();
        
        System.out.println("\nfinalMethod():");
        child.finalMethod();
        
        System.out.println("\ncallPrivateMethod() (calls parent's private method):");
        child.callPrivateMethod();
        
        System.out.println("\n--- Static Members ---");
        System.out.println("ParentClass.staticCount: " + ParentClass.staticCount);
        System.out.println("Calling static method via parent: ");
        ParentClass.staticMethod();
        System.out.println("Calling static method via child: ");
        ChildClass.staticMethod();    // Inherited but accessed via class
    }
}

OUTPUT:
-------
=== What Is Inherited Demo ===

--- Creating Child Object ---
ParentClass constructor called
ChildClass constructor called

--- Testing Field Access ---
Accessing fields from Child class:
  publicField: Public Field
  protectedField: Protected Field
  defaultField: Default Field
  privateField via getter: Private Field

--- Testing Method Inheritance ---
Calling methods on child object:

publicMethod():
Public method OVERRIDDEN in Child

protectedMethod():
Protected method OVERRIDDEN in Child

defaultMethod():
Default method in Parent

finalMethod():
Final method in Parent - cannot be overridden

callPrivateMethod() (calls parent's private method):
Private method in Parent

--- Static Members ---
ParentClass.staticCount: 1
Calling static method via parent: 
Static method in Parent
Calling static method via child: 
Static method in Parent


================================================================================
                    7. 'INSTANCEOF' OPERATOR
================================================================================

The 'instanceof' operator is used to check if an object is an instance of a
specific class or implements a specific interface.

Syntax:
-------
object instanceof ClassName


--------------------------------------------------------------------------------
EXAMPLE 7: instanceof Operator
--------------------------------------------------------------------------------

class Animal {
    public void makeSound() {
        System.out.println("Some sound...");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Woof!");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Meow!");
    }
}

class Bird extends Animal {
    public void chirp() {
        System.out.println("Chirp!");
    }
}

public class InstanceofDemo {
    public static void main(String[] args) {
        
        System.out.println("=== instanceof Operator Demo ===\n");
        
        // Create objects
        Animal animal = new Animal();
        Dog dog = new Dog();
        Cat cat = new Cat();
        Animal animalDog = new Dog();    // Parent reference, child object
        
        // Basic instanceof checks
        System.out.println("--- Basic instanceof Checks ---");
        System.out.println("dog instanceof Dog: " + (dog instanceof Dog));
        System.out.println("dog instanceof Animal: " + (dog instanceof Animal));
        System.out.println("dog instanceof Object: " + (dog instanceof Object));
        System.out.println("animal instanceof Dog: " + (animal instanceof Dog));
        System.out.println("animalDog instanceof Dog: " + (animalDog instanceof Dog));
        
        System.out.println("\n--- Practical Use: Type Checking Before Cast ---");
        
        // Array of different animals
        Animal[] animals = {new Dog(), new Cat(), new Bird(), new Dog()};
        
        for (int i = 0; i < animals.length; i++) {
            System.out.println("\nAnimal " + (i + 1) + ":");
            
            if (animals[i] instanceof Dog) {
                System.out.println("  This is a Dog");
                Dog d = (Dog) animals[i];    // Safe cast
                d.bark();
            } else if (animals[i] instanceof Cat) {
                System.out.println("  This is a Cat");
                Cat c = (Cat) animals[i];
                c.meow();
            } else if (animals[i] instanceof Bird) {
                System.out.println("  This is a Bird");
                Bird b = (Bird) animals[i];
                b.chirp();
            }
        }
        
        System.out.println("\n--- Null Check ---");
        Dog nullDog = null;
        System.out.println("nullDog instanceof Dog: " + (nullDog instanceof Dog));
        System.out.println("(null always returns false)");
    }
}

OUTPUT:
-------
=== instanceof Operator Demo ===

--- Basic instanceof Checks ---
dog instanceof Dog: true
dog instanceof Animal: true
dog instanceof Object: true
animal instanceof Dog: false
animalDog instanceof Dog: true

--- Practical Use: Type Checking Before Cast ---

Animal 1:
  This is a Dog
Woof!

Animal 2:
  This is a Cat
Meow!

Animal 3:
  This is a Bird
Chirp!

Animal 4:
  This is a Dog
Woof!

--- Null Check ---
nullDog instanceof Dog: false
(null always returns false)


================================================================================
                    8. INHERITANCE IN AUTOMATION CONTEXT
================================================================================

--------------------------------------------------------------------------------
EXAMPLE 8: Base Test Class Pattern
--------------------------------------------------------------------------------

// BaseTest.java - Parent class for all tests
class BaseTest {
    
    // Common fields
    protected String browserName;
    protected String baseUrl;
    protected int implicitWait;
    protected boolean isSetupComplete;
    
    // Constructor
    public BaseTest() {
        this.browserName = "chrome";
        this.baseUrl = "https://example.com";
        this.implicitWait = 10;
        this.isSetupComplete = false;
    }
    
    // Setup method - to be called before tests
    public void setUp() {
        System.out.println("[BaseTest] Setting up test environment...");
        System.out.println("[BaseTest] Browser: " + browserName);
        System.out.println("[BaseTest] Base URL: " + baseUrl);
        System.out.println("[BaseTest] Implicit Wait: " + implicitWait + " seconds");
        // driver = new ChromeDriver();
        // driver.manage().window().maximize();
        // driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWait));
        isSetupComplete = true;
        System.out.println("[BaseTest] Setup complete!");
    }
    
    // Teardown method - to be called after tests
    public void tearDown() {
        System.out.println("[BaseTest] Tearing down test environment...");
        // driver.quit();
        isSetupComplete = false;
        System.out.println("[BaseTest] Teardown complete!");
    }
    
    // Common utility methods
    public void navigateTo(String url) {
        System.out.println("[BaseTest] Navigating to: " + url);
        // driver.get(url);
    }
    
    public void takeScreenshot(String fileName) {
        System.out.println("[BaseTest] Taking screenshot: " + fileName);
        // Screenshot logic
    }
    
    public void logInfo(String message) {
        System.out.println("[INFO] " + message);
    }
    
    public void logError(String message) {
        System.out.println("[ERROR] " + message);
    }
    
    protected void waitForElement(String locator, int timeout) {
        System.out.println("[BaseTest] Waiting for element: " + locator + " (timeout: " + timeout + "s)");
        // WebDriverWait logic
    }
}

// LoginTest.java - Child class for login tests
class LoginTest extends BaseTest {
    
    private String loginUrl;
    
    public LoginTest() {
        super();
        this.loginUrl = baseUrl + "/login";
    }
    
    @Override
    public void setUp() {
        super.setUp();    // Call parent setup first
        System.out.println("[LoginTest] Additional setup for login tests...");
        System.out.println("[LoginTest] Login URL: " + loginUrl);
    }
    
    @Override
    public void tearDown() {
        System.out.println("[LoginTest] Cleaning up login test data...");
        super.tearDown();    // Call parent teardown
    }
    
    public void testValidLogin() {
        logInfo("Starting Valid Login Test");
        navigateTo(loginUrl);
        
        System.out.println("[LoginTest] Entering username: testuser");
        System.out.println("[LoginTest] Entering password: ****");
        System.out.println("[LoginTest] Clicking login button");
        
        // Assertions
        System.out.println("[LoginTest] Verifying successful login...");
        logInfo("Valid Login Test PASSED");
    }
    
    public void testInvalidLogin() {
        logInfo("Starting Invalid Login Test");
        navigateTo(loginUrl);
        
        System.out.println("[LoginTest] Entering invalid credentials");
        System.out.println("[LoginTest] Verifying error message...");
        
        logInfo("Invalid Login Test PASSED");
    }
}

// SearchTest.java - Another child class
class SearchTest extends BaseTest {
    
    private String searchUrl;
    
    public SearchTest() {
        super();
        this.searchUrl = baseUrl + "/search";
    }
    
    @Override
    public void setUp() {
        super.setUp();
        System.out.println("[SearchTest] Additional setup for search tests...");
    }
    
    public void testProductSearch() {
        logInfo("Starting Product Search Test");
        navigateTo(searchUrl);
        
        System.out.println("[SearchTest] Entering search term: laptop");
        System.out.println("[SearchTest] Clicking search button");
        System.out.println("[SearchTest] Verifying search results...");
        
        logInfo("Product Search Test PASSED");
    }
}

// Demo class
public class BaseTestPatternDemo {
    public static void main(String[] args) {
        
        System.out.println("=".repeat(60));
        System.out.println("          BASE TEST PATTERN DEMO");
        System.out.println("=".repeat(60));
        
        // Run Login Tests
        System.out.println("\n--- LOGIN TEST EXECUTION ---\n");
        LoginTest loginTest = new LoginTest();
        loginTest.setUp();
        System.out.println();
        loginTest.testValidLogin();
        System.out.println();
        loginTest.testInvalidLogin();
        System.out.println();
        loginTest.tearDown();
        
        System.out.println("\n" + "=".repeat(60) + "\n");
        
        // Run Search Tests
        System.out.println("--- SEARCH TEST EXECUTION ---\n");
        SearchTest searchTest = new SearchTest();
        searchTest.setUp();
        System.out.println();
        searchTest.testProductSearch();
        System.out.println();
        searchTest.tearDown();
        
        System.out.println("\n" + "=".repeat(60));
        System.out.println("          TEST EXECUTION COMPLETED");
        System.out.println("=".repeat(60));
    }
}

OUTPUT:
-------
============================================================
          BASE TEST PATTERN DEMO
============================================================

--- LOGIN TEST EXECUTION ---

[BaseTest] Setting up test environment...
[BaseTest] Browser: chrome
[BaseTest] Base URL: https://example.com
[BaseTest] Implicit Wait: 10 seconds
[BaseTest] Setup complete!
[LoginTest] Additional setup for login tests...
[LoginTest] Login URL: https://example.com/login

[INFO] Starting Valid Login Test
[BaseTest] Navigating to: https://example.com/login
[LoginTest] Entering username: testuser
[LoginTest] Entering password: ****
[LoginTest] Clicking login button
[LoginTest] Verifying successful login...
[INFO] Valid Login Test PASSED

[INFO] Starting Invalid Login Test
[BaseTest] Navigating to: https://example.com/login
[LoginTest] Entering invalid credentials
[LoginTest] Verifying error message...
[INFO] Invalid Login Test PASSED

[LoginTest] Cleaning up login test data...
[BaseTest] Tearing down test environment...
[BaseTest] Teardown complete!

============================================================

--- SEARCH TEST EXECUTION ---

[BaseTest] Setting up test environment...
[BaseTest] Browser: chrome
[BaseTest] Base URL: https://example.com
[BaseTest] Implicit Wait: 10 seconds
[BaseTest] Setup complete!
[SearchTest] Additional setup for search tests...

[INFO] Starting Product Search Test
[BaseTest] Navigating to: https://example.com/search
[SearchTest] Entering search term: laptop
[SearchTest] Clicking search button
[SearchTest] Verifying search results...
[INFO] Product Search Test PASSED

[BaseTest] Tearing down test environment...
[BaseTest] Teardown complete!

============================================================
          TEST EXECUTION COMPLETED
============================================================


--------------------------------------------------------------------------------
EXAMPLE 9: Page Object Base Class Pattern
--------------------------------------------------------------------------------

// BasePage.java - Parent class for all page objects
class BasePage {
    
    protected String pageUrl;
    protected String pageTitle;
    
    public BasePage() {
        System.out.println("[BasePage] Base page initialized");
    }
    
    // Common methods for all pages
    public void waitForPageLoad() {
        System.out.println("[BasePage] Waiting for page to load...");
        // WebDriverWait logic
    }
    
    public String getPageTitle() {
        System.out.println("[BasePage] Getting page title");
        return pageTitle;
    }
    
    public void scrollToTop() {
        System.out.println("[BasePage] Scrolling to top of page");
        // JavaScript scroll
    }
    
    public void scrollToBottom() {
        System.out.println("[BasePage] Scrolling to bottom of page");
    }
    
    public void scrollToElement(String element) {
        System.out.println("[BasePage] Scrolling to element: " + element);
    }
    
    protected void click(String locator) {
        System.out.println("[BasePage] Clicking: " + locator);
        // driver.findElement(By.xpath(locator)).click();
    }
    
    protected void type(String locator, String text) {
        System.out.println("[BasePage] Typing '" + text + "' into: " + locator);
        // driver.findElement(By.xpath(locator)).sendKeys(text);
    }
    
    protected String getText(String locator) {
        System.out.println("[BasePage] Getting text from: " + locator);
        return "Sample Text";
    }
    
    protected boolean isDisplayed(String locator) {
        System.out.println("[BasePage] Checking if displayed: " + locator);
        return true;
    }
}

// LoginPage.java
class LoginPage extends BasePage {
    
    // Locators
    private final String usernameField = "//input[@id='username']";
    private final String passwordField = "//input[@id='password']";
    private final String loginButton = "//button[@id='login']";
    private final String errorMessage = "//div[@class='error']";
    
    public LoginPage() {
        super();
        this.pageUrl = "https://example.com/login";
        this.pageTitle = "Login Page";
        System.out.println("[LoginPage] Login page initialized");
    }
    
    public void enterUsername(String username) {
        type(usernameField, username);
    }
    
    public void enterPassword(String password) {
        type(passwordField, "****");    // Mask password in logs
    }
    
    public void clickLogin() {
        click(loginButton);
    }
    
    public HomePage login(String username, String password) {
        System.out.println("[LoginPage] Performing login...");
        enterUsername(username);
        enterPassword(password);
        clickLogin();
        return new HomePage();
    }
    
    public String getErrorMessage() {
        return getText(errorMessage);
    }
    
    public boolean isErrorDisplayed() {
        return isDisplayed(errorMessage);
    }
}

// HomePage.java
class HomePage extends BasePage {
    
    // Locators
    private final String welcomeMessage = "//div[@id='welcome']";
    private final String searchBox = "//input[@id='search']";
    private final String searchButton = "//button[@id='search-btn']";
    private final String logoutButton = "//button[@id='logout']";
    
    public HomePage() {
        super();
        this.pageUrl = "https://example.com/home";
        this.pageTitle = "Home Page";
        System.out.println("[HomePage] Home page initialized");
    }
    
    public String getWelcomeMessage() {
        return getText(welcomeMessage);
    }
    
    public void search(String term) {
        System.out.println("[HomePage] Searching for: " + term);
        type(searchBox, term);
        click(searchButton);
    }
    
    public LoginPage logout() {
        System.out.println("[HomePage] Logging out...");
        click(logoutButton);
        return new LoginPage();
    }
    
    public boolean isUserLoggedIn() {
        return isDisplayed(welcomeMessage);
    }
}

// Demo
public class PageObjectPatternDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Page Object Pattern Demo ===\n");
        
        // Create page objects
        LoginPage loginPage = new LoginPage();
        
        System.out.println("\n--- Login Flow ---");
        loginPage.waitForPageLoad();
        HomePage homePage = loginPage.login("testuser", "password123");
        
        System.out.println("\n--- Home Page Actions ---");
        homePage.waitForPageLoad();
        System.out.println("Welcome Message: " + homePage.getWelcomeMessage());
        System.out.println("User Logged In: " + homePage.isUserLoggedIn());
        homePage.search("selenium");
        
        System.out.println("\n--- Logout ---");
        LoginPage loginAgain = homePage.logout();
        System.out.println("Returned to login page");
    }
}

OUTPUT:
-------
=== Page Object Pattern Demo ===

[BasePage] Base page initialized
[LoginPage] Login page initialized

--- Login Flow ---
[BasePage] Waiting for page to load...
[LoginPage] Performing login...
[BasePage] Typing 'testuser' into: //input[@id='username']
[BasePage] Typing '****' into: //input[@id='password']
[BasePage] Clicking: //button[@id='login']
[BasePage] Base page initialized
[HomePage] Home page initialized

--- Home Page Actions ---
[BasePage] Waiting for page to load...
[BasePage] Getting text from: //div[@id='welcome']
Welcome Message: Sample Text
[BasePage] Checking if displayed: //div[@id='welcome']
User Logged In: true
[HomePage] Searching for: selenium
[BasePage] Typing 'selenium' into: //input[@id='search']
[BasePage] Clicking: //button[@id='search-btn']

--- Logout ---
[HomePage] Logging out...
[BasePage] Clicking: //button[@id='logout']
[BasePage] Base page initialized
[LoginPage] Login page initialized
Returned to login page


--------------------------------------------------------------------------------
EXAMPLE 10: API Test Base Class
--------------------------------------------------------------------------------

// BaseApiTest.java
class BaseApiTest {
    
    protected String baseUri;
    protected String contentType;
    protected int defaultTimeout;
    
    public BaseApiTest() {
        this.baseUri = "https://api.example.com";
        this.contentType = "application/json";
        this.defaultTimeout = 30;
    }
    
    public void setUp() {
        System.out.println("[BaseApiTest] Setting up API test environment");
        System.out.println("[BaseApiTest] Base URI: " + baseUri);
        System.out.println("[BaseApiTest] Content Type: " + contentType);
        // RestAssured.baseURI = baseUri;
    }
    
    public void tearDown() {
        System.out.println("[BaseApiTest] Cleaning up API test");
        // Reset configurations
    }
    
    protected void logRequest(String method, String endpoint, String body) {
        System.out.println("[REQUEST] " + method + " " + endpoint);
        if (body != null && !body.isEmpty()) {
            System.out.println("[REQUEST BODY] " + body);
        }
    }
    
    protected void logResponse(int statusCode, String body) {
        System.out.println("[RESPONSE] Status Code: " + statusCode);
        System.out.println("[RESPONSE BODY] " + body);
    }
    
    protected void validateStatusCode(int actual, int expected) {
        if (actual == expected) {
            System.out.println("[PASS] Status code validation: Expected " + expected + ", Got " + actual);
        } else {
            System.out.println("[FAIL] Status code validation: Expected " + expected + ", Got " + actual);
        }
    }
    
    protected void validateResponseTime(long actual, long maxAllowed) {
        if (actual <= maxAllowed) {
            System.out.println("[PASS] Response time: " + actual + "ms (max: " + maxAllowed + "ms)");
        } else {
            System.out.println("[FAIL] Response time: " + actual + "ms exceeded max: " + maxAllowed + "ms");
        }
    }
}

// UserApiTest.java
class UserApiTest extends BaseApiTest {
    
    private String usersEndpoint;
    
    public UserApiTest() {
        super();
        this.usersEndpoint = "/users";
    }
    
    @Override
    public void setUp() {
        super.setUp();
        System.out.println("[UserApiTest] Additional setup for User API tests");
    }
    
    public void testGetAllUsers() {
        System.out.println("\n--- Test: Get All Users ---");
        String endpoint = baseUri + usersEndpoint;
        
        logRequest("GET", endpoint, null);
        
        // Simulated response
        int statusCode = 200;
        String responseBody = "[{\"id\":1,\"name\":\"John\"},{\"id\":2,\"name\":\"Jane\"}]";
        long responseTime = 150;
        
        logResponse(statusCode, responseBody);
        validateStatusCode(statusCode, 200);
        validateResponseTime(responseTime, 500);
    }
    
    public void testCreateUser() {
        System.out.println("\n--- Test: Create User ---");
        String endpoint = baseUri + usersEndpoint;
        String requestBody = "{\"name\":\"New User\",\"email\":\"new@test.com\"}";
        
        logRequest("POST", endpoint, requestBody);
        
        // Simulated response
        int statusCode = 201;
        String responseBody = "{\"id\":3,\"name\":\"New User\",\"email\":\"new@test.com\"}";
        long responseTime = 200;
        
        logResponse(statusCode, responseBody);
        validateStatusCode(statusCode, 201);
        validateResponseTime(responseTime, 500);
    }
    
    public void testGetUserById() {
        System.out.println("\n--- Test: Get User By ID ---");
        int userId = 1;
        String endpoint = baseUri + usersEndpoint + "/" + userId;
        
        logRequest("GET", endpoint, null);
        
        // Simulated response
        int statusCode = 200;
        String responseBody = "{\"id\":1,\"name\":\"John\",\"email\":\"john@test.com\"}";
        long responseTime = 100;
        
        logResponse(statusCode, responseBody);
        validateStatusCode(statusCode, 200);
        validateResponseTime(responseTime, 500);
    }
}

// Demo
public class ApiTestPatternDemo {
    public static void main(String[] args) {
        
        System.out.println("=".repeat(60));
        System.out.println("          API TEST PATTERN DEMO");
        System.out.println("=".repeat(60));
        
        UserApiTest userApiTest = new UserApiTest();
        
        userApiTest.setUp();
        
        userApiTest.testGetAllUsers();
        userApiTest.testCreateUser();
        userApiTest.testGetUserById();
        
        userApiTest.tearDown();
        
        System.out.println("\n" + "=".repeat(60));
        System.out.println("          API TESTS COMPLETED");
        System.out.println("=".repeat(60));
    }
}

OUTPUT:
-------
============================================================
          API TEST PATTERN DEMO
============================================================
[BaseApiTest] Setting up API test environment
[BaseApiTest] Base URI: https://api.example.com
[BaseApiTest] Content Type: application/json
[UserApiTest] Additional setup for User API tests

--- Test: Get All Users ---
[REQUEST] GET https://api.example.com/users
[RESPONSE] Status Code: 200
[RESPONSE BODY] [{"id":1,"name":"John"},{"id":2,"name":"Jane"}]
[PASS] Status code validation: Expected 200, Got 200
[PASS] Response time: 150ms (max: 500ms)

--- Test: Create User ---
[REQUEST] POST https://api.example.com/users
[REQUEST BODY] {"name":"New User","email":"new@test.com"}
[RESPONSE] Status Code: 201
[RESPONSE BODY] {"id":3,"name":"New User","email":"new@test.com"}
[PASS] Status code validation: Expected 201, Got 201
[PASS] Response time: 200ms (max: 500ms)

--- Test: Get User By ID ---
[REQUEST] GET https://api.example.com/users/1
[RESPONSE] Status Code: 200
[RESPONSE BODY] {"id":1,"name":"John","email":"john@test.com"}
[PASS] Status code validation: Expected 200, Got 200
[PASS] Response time: 100ms (max: 500ms)
[BaseApiTest] Cleaning up API test

============================================================
          API TESTS COMPLETED
============================================================


================================================================================
================================================================================
                    NEGATIVE SCENARIOS - INHERITANCE
================================================================================
================================================================================


--------------------------------------------------------------------------------
ERROR 1: Multiple Inheritance Not Allowed (with classes)
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Father {
    public void work() {
        System.out.println("Father working");
    }
}

class Mother {
    public void cook() {
        System.out.println("Mother cooking");
    }
}

// Multiple inheritance - NOT ALLOWED!
class Child extends Father, Mother {    // ERROR!
    public void play() {
        System.out.println("Child playing");
    }
}

ERROR MESSAGE:
--------------
error: '{' expected
class Child extends Father, Mother {
                          ^

FIX:
----
// Option 1: Use single inheritance with composition
class Father {
    public void work() {
        System.out.println("Father working");
    }
}

class Mother {
    public void cook() {
        System.out.println("Mother cooking");
    }
}

class Child extends Father {
    private Mother mother = new Mother();    // Composition
    
    public void play() {
        System.out.println("Child playing");
    }
    
    public void helpMomCook() {
        mother.cook();    // Delegate to Mother
    }
}

// Option 2: Use interfaces (covered in later topic)
interface Workable {
    void work();
}

interface Cookable {
    void cook();
}

class ChildWithInterfaces implements Workable, Cookable {
    @Override
    public void work() {
        System.out.println("Child working");
    }
    
    @Override
    public void cook() {
        System.out.println("Child cooking");
    }
}


--------------------------------------------------------------------------------
ERROR 2: Cannot Extend Final Class
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
final class FinalClass {
    public void display() {
        System.out.println("Final class method");
    }
}

// Cannot extend final class!
class ChildOfFinal extends FinalClass {    // ERROR!
    public void show() {
        System.out.println("Child method");
    }
}

ERROR MESSAGE:
--------------
error: cannot inherit from final FinalClass
class ChildOfFinal extends FinalClass {
                           ^

FIX:
----
// Option 1: Remove final modifier if you control the class
class NonFinalClass {
    public void display() {
        System.out.println("Non-final class method");
    }
}

class ChildClass extends NonFinalClass {
    public void show() {
        System.out.println("Child method");
    }
}

// Option 2: Use composition instead
final class FinalClass {
    public void display() {
        System.out.println("Final class method");
    }
}

class WrapperClass {
    private FinalClass finalObj = new FinalClass();
    
    public void display() {
        finalObj.display();    // Delegate
    }
    
    public void show() {
        System.out.println("Wrapper method");
    }
}


--------------------------------------------------------------------------------
ERROR 3: Cannot Override Final Method
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public final void finalMethod() {
        System.out.println("This is a final method");
    }
}

class Child extends Parent {
    @Override
    public void finalMethod() {    // ERROR! Cannot override final method
        System.out.println("Trying to override");
    }
}

ERROR MESSAGE:
--------------
error: finalMethod() in Child cannot override finalMethod() in Parent
    public void finalMethod() {
                ^
  overridden method is final

FIX:
----
class Parent {
    public final void finalMethod() {
        System.out.println("This is a final method");
    }
    
    public void nonFinalMethod() {
        System.out.println("This can be overridden");
    }
}

class Child extends Parent {
    // Cannot override finalMethod, but can add new methods
    
    @Override
    public void nonFinalMethod() {
        System.out.println("Overridden non-final method");
    }
    
    public void childMethod() {
        // Can still call parent's final method
        finalMethod();
    }
}


--------------------------------------------------------------------------------
ERROR 4: super() Must Be First Statement
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public Parent(String name) {
        System.out.println("Parent: " + name);
    }
}

class Child extends Parent {
    public Child(String name) {
        System.out.println("Before super");    // ERROR!
        super(name);    // super() must be first!
    }
}

ERROR MESSAGE:
--------------
error: call to super must be first statement in constructor
        super(name);
             ^

FIX:
----
class Parent {
    public Parent(String name) {
        System.out.println("Parent: " + name);
    }
}

class Child extends Parent {
    public Child(String name) {
        super(name);    // Must be first statement
        System.out.println("After super");
        // Other initialization code
    }
}


--------------------------------------------------------------------------------
ERROR 5: No Default Constructor in Parent
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    private String name;
    
    // Only parameterized constructor
    public Parent(String name) {
        this.name = name;
    }
}

class Child extends Parent {
    // Implicit super() tries to call Parent() which doesn't exist!
    public Child() {    // ERROR!
        System.out.println("Child constructor");
    }
}

ERROR MESSAGE:
--------------
error: constructor Parent in class Parent cannot be applied to given types;
    public Child() {
                   ^
  required: String
  found: no arguments

FIX:
----
class Parent {
    private String name;
    
    // Add no-arg constructor
    public Parent() {
        this.name = "Default";
    }
    
    public Parent(String name) {
        this.name = name;
    }
}

class Child extends Parent {
    public Child() {
        // Now implicit super() works
        System.out.println("Child constructor");
    }
}

// OR explicitly call parameterized constructor
class Child2 extends Parent {
    public Child2() {
        super("Default Name");    // Explicitly call parent constructor
        System.out.println("Child2 constructor");
    }
}


--------------------------------------------------------------------------------
ERROR 6: Cannot Reduce Visibility in Override
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public void publicMethod() {
        System.out.println("Public method");
    }
    
    protected void protectedMethod() {
        System.out.println("Protected method");
    }
}

class Child extends Parent {
    // Cannot reduce visibility from public to private
    @Override
    private void publicMethod() {    // ERROR!
        System.out.println("Trying to make private");
    }
    
    // Cannot reduce visibility from protected to private
    @Override
    private void protectedMethod() {    // ERROR!
        System.out.println("Trying to make private");
    }
}

ERROR MESSAGE:
--------------
error: publicMethod() in Child cannot override publicMethod() in Parent
    private void publicMethod() {
                 ^
  attempting to assign weaker access privileges; was public

FIX:
----
class Parent {
    public void publicMethod() {
        System.out.println("Public method");
    }
    
    protected void protectedMethod() {
        System.out.println("Protected method");
    }
}

class Child extends Parent {
    // Can keep same visibility
    @Override
    public void publicMethod() {
        System.out.println("Overridden public method");
    }
    
    // Can increase visibility (protected -> public)
    @Override
    public void protectedMethod() {
        System.out.println("Overridden with increased visibility");
    }
}

VISIBILITY RULES:
-----------------
+------------------+------------------------------------------+
| Parent Method    | Child Method Can Be                      |
+------------------+------------------------------------------+
| public           | public only                              |
| protected        | protected or public                      |
| default          | default, protected, or public            |
| private          | N/A (not inherited)                      |
+------------------+------------------------------------------+


--------------------------------------------------------------------------------
ERROR 7: Incompatible Return Type in Override
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public String getMessage() {
        return "Parent message";
    }
    
    public Number getNumber() {
        return 10;
    }
}

class Child extends Parent {
    // Incompatible return type
    @Override
    public int getMessage() {    // ERROR! int is not compatible with String
        return 0;
    }
    
    // This is OK - Integer is subtype of Number (covariant return)
    @Override
    public Integer getNumber() {
        return 20;
    }
}

ERROR MESSAGE:
--------------
error: getMessage() in Child cannot override getMessage() in Parent
    public int getMessage() {
               ^
  return type int is not compatible with String

FIX:
----
class Parent {
    public String getMessage() {
        return "Parent message";
    }
    
    public Number getNumber() {
        return 10;
    }
}

class Child extends Parent {
    // Same return type
    @Override
    public String getMessage() {
        return "Child message";
    }
    
    // Covariant return type (subtype is OK)
    @Override
    public Integer getNumber() {
        return 20;
    }
}


--------------------------------------------------------------------------------
ERROR 8: Calling super in Static Method
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public void instanceMethod() {
        System.out.println("Parent instance method");
    }
    
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    public static void childStaticMethod() {
        super.staticMethod();    // ERROR! Cannot use super in static context
    }
}

ERROR MESSAGE:
--------------
error: non-static variable super cannot be referenced from a static context
        super.staticMethod();
        ^

FIX:
----
class Parent {
    public void instanceMethod() {
        System.out.println("Parent instance method");
    }
    
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    // Option 1: Use class name instead of super
    public static void childStaticMethod() {
        Parent.staticMethod();    // Use class name for static methods
    }
    
    // Option 2: Make it non-static if you need super
    public void childInstanceMethod() {
        super.instanceMethod();    // OK in instance method
    }
}


--------------------------------------------------------------------------------
ERROR 9: ClassCastException - Invalid Downcasting
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal {
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barking");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat meowing");
    }
}

public class CastingError {
    public static void main(String[] args) {
        Animal animal = new Cat();
        Dog dog = (Dog)
        
--- ai stopped ---

--------------------------------------------------------------------------------
ERROR 9: ClassCastException - Invalid Downcasting
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal {
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barking");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat meowing");
    }
}

public class CastingError {
    public static void main(String[] args) {
        Animal animal = new Cat();    // Animal reference, Cat object
        Dog dog = (Dog) animal;       // ERROR at runtime! Cat cannot be cast to Dog
        dog.bark();
    }
}

ERROR MESSAGE (Runtime):
------------------------
Exception in thread "main" java.lang.ClassCastException: 
    Cat cannot be cast to Dog
    at CastingError.main(CastingError.java:5)

EXPLANATION:
------------
- The object is actually a Cat, stored in Animal reference
- Trying to cast it to Dog fails because Cat IS-NOT-A Dog
- Compiler allows it (both are subtypes of Animal)
- But runtime check fails

FIX:
----
class Animal {
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barking");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat meowing");
    }
}

public class CastingFixed {
    public static void main(String[] args) {
        
        // Example 1: Correct casting
        Animal animal1 = new Dog();    // Animal reference, Dog object
        if (animal1 instanceof Dog) {
            Dog dog = (Dog) animal1;   // Safe - object IS actually a Dog
            dog.bark();
        }
        
        // Example 2: Using instanceof to prevent ClassCastException
        Animal animal2 = new Cat();
        
        if (animal2 instanceof Dog) {
            Dog dog = (Dog) animal2;
            dog.bark();
        } else if (animal2 instanceof Cat) {
            Cat cat = (Cat) animal2;   // Safe - object IS actually a Cat
            cat.meow();
        }
        
        // Example 3: Processing array of mixed animals safely
        Animal[] animals = {new Dog(), new Cat(), new Dog(), new Cat()};
        
        for (Animal a : animals) {
            a.eat();    // Common method - always safe
            
            if (a instanceof Dog) {
                ((Dog) a).bark();
            } else if (a instanceof Cat) {
                ((Cat) a).meow();
            }
        }
    }
}

OUTPUT:
-------
Dog barking
Cat meowing
Animal eating
Dog barking
Animal eating
Cat meowing
Animal eating
Dog barking
Animal eating
Cat meowing


--------------------------------------------------------------------------------
ERROR 10: Cyclic Inheritance Not Allowed
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class A extends B {    // A extends B
}

class B extends A {    // B extends A - Creates cycle!
}

ERROR MESSAGE:
--------------
error: cyclic inheritance involving A
class A extends B {
^

FIX:
----
// Inheritance must be hierarchical, not circular
class A {
    // Base class
}

class B extends A {
    // B extends A (one direction only)
}

class C extends B {
    // C extends B extends A (chain, not cycle)
}


--------------------------------------------------------------------------------
ERROR 11: Cannot Access Private Members of Parent
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    private String secret = "Parent's secret";
    
    private void privateMethod() {
        System.out.println("Private method");
    }
}

class Child extends Parent {
    public void tryAccessPrivate() {
        System.out.println(secret);        // ERROR! Cannot access
        privateMethod();                    // ERROR! Cannot access
    }
}

ERROR MESSAGE:
--------------
error: secret has private access in Parent
        System.out.println(secret);
                           ^
error: privateMethod() has private access in Parent
        privateMethod();
        ^

FIX:
----
class Parent {
    private String secret = "Parent's secret";
    
    private void privateMethod() {
        System.out.println("Private method");
    }
    
    // Provide protected or public access
    protected String getSecret() {
        return secret;
    }
    
    protected void callPrivateMethod() {
        privateMethod();
    }
}

class Child extends Parent {
    public void accessThroughGetters() {
        System.out.println(getSecret());      // OK - using getter
        callPrivateMethod();                   // OK - using wrapper method
    }
}


--------------------------------------------------------------------------------
ERROR 12: Constructor Cannot Be Inherited
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    private String name;
    
    public Parent(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}

class Child extends Parent {
    // No constructor defined
    // Expects to inherit Parent(String name)
}

public class ConstructorInheritanceError {
    public static void main(String[] args) {
        Child child = new Child("Test");    // ERROR!
    }
}

ERROR MESSAGE:
--------------
error: constructor Child in class Child cannot be applied to given types;
        Child child = new Child("Test");
                      ^
  required: no arguments
  found: String

EXPLANATION:
------------
Constructors are NOT inherited. Java tries to call Child() which implicitly
calls super(), but Parent has no no-arg constructor.

FIX:
----
class Parent {
    private String name;
    
    public Parent(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}

class Child extends Parent {
    // Must explicitly define constructor that calls parent constructor
    public Child(String name) {
        super(name);    // Call parent constructor
    }
    
    // Can also add additional constructors
    public Child() {
        super("Default Name");    // Must still call parent constructor
    }
}

public class ConstructorInheritanceFixed {
    public static void main(String[] args) {
        Child child1 = new Child("Test");      // Works!
        Child child2 = new Child();            // Also works!
        
        System.out.println(child1.getName());  // Output: Test
        System.out.println(child2.getName());  // Output: Default Name
    }
}


--------------------------------------------------------------------------------
ERROR 13: Hiding vs Overriding Static Methods
--------------------------------------------------------------------------------

PROBLEMATIC CODE (Misconception):
---------------------------------
class Parent {
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    @Override    // ERROR! Cannot use @Override for static methods
    public static void staticMethod() {
        System.out.println("Child static method");
    }
}

ERROR MESSAGE:
--------------
error: method does not override or implement a method from a supertype
    @Override
    ^

EXPLANATION:
------------
Static methods cannot be overridden - they can only be HIDDEN.
Method hiding is different from overriding:
- Overriding: Runtime polymorphism (dynamic binding)
- Hiding: Compile-time resolution (static binding)

FIX AND DEMONSTRATION:
----------------------
class Parent {
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
    
    public void instanceMethod() {
        System.out.println("Parent instance method");
    }
}

class Child extends Parent {
    // This HIDES parent's static method (not override)
    public static void staticMethod() {
        System.out.println("Child static method");
    }
    
    // This OVERRIDES parent's instance method
    @Override
    public void instanceMethod() {
        System.out.println("Child instance method");
    }
}

public class HidingVsOverriding {
    public static void main(String[] args) {
        Parent p = new Child();
        
        // Static method - resolved at compile time based on reference type
        p.staticMethod();           // Output: Parent static method (HIDING)
        
        // Instance method - resolved at runtime based on object type
        p.instanceMethod();         // Output: Child instance method (OVERRIDING)
        
        // To call child's static method, use Child reference
        Child c = new Child();
        c.staticMethod();           // Output: Child static method
        
        // Best practice: Call static methods using class name
        Parent.staticMethod();      // Output: Parent static method
        Child.staticMethod();       // Output: Child static method
    }
}

OUTPUT:
-------
Parent static method
Child instance method
Child static method
Parent static method
Child static method


================================================================================
                    INHERITANCE - QUICK REFERENCE
================================================================================

SYNTAX SUMMARY:
---------------
+--------------------------------+----------------------------------------------+
| Concept                        | Syntax                                       |
+--------------------------------+----------------------------------------------+
| Basic inheritance              | class Child extends Parent { }               |
| Call parent constructor        | super() or super(args)                       |
| Access parent field            | super.fieldName                              |
| Call parent method             | super.methodName()                           |
| Override method                | @Override before method                      |
| Prevent inheritance            | final class ClassName { }                    |
| Prevent override               | final returnType methodName() { }            |
| Check object type              | object instanceof ClassName                  |
+--------------------------------+----------------------------------------------+


WHAT IS INHERITED:
------------------
+------------------+-------------+------------------+---------------------------+
| Member           | Inherited?  | Accessible?      | Notes                     |
+------------------+-------------+------------------+---------------------------+
| public           | Yes         | Yes              | Fully accessible          |
| protected        | Yes         | Yes              | Accessible in child       |
| default          | Yes*        | Same package     | Package-private           |
| private          | No          | No               | Use getters/setters       |
| Constructors     | No          | Via super()      | Must explicitly call      |
| static members   | Inherited   | Via class name   | Not truly polymorphic     |
+------------------+-------------+------------------+---------------------------+


OVERRIDING RULES:
-----------------
1. Same method name
2. Same parameters
3. Same or covariant return type
4. Same or less restrictive access
5. Cannot override: final, static, private
6. Use @Override annotation


CONSTRUCTOR CHAINING:
---------------------
Child Object Creation:
    Child()  super()  Parent()  super()  GrandParent()  Object()
    
    Then executes in reverse:
    Object() completes  GrandParent() completes  Parent() completes  Child() completes


COMMON PATTERNS IN AUTOMATION:
------------------------------
1. BaseTest  LoginTest, SearchTest, CheckoutTest
2. BasePage  LoginPage, HomePage, ProductPage
3. BaseApiTest  UserApiTest, OrderApiTest
4. BaseDriver  ChromeDriver, FirefoxDriver setup


================================================================================
                    PRACTICE EXERCISES - INHERITANCE
================================================================================

EXERCISE 1: Employee Hierarchy
------------------------------
Create:
- Employee (base): name, id, salary, displayInfo(), calculateBonus()
- Manager extends Employee: teamSize, override calculateBonus (15%)
- Developer extends Employee: programmingLanguage, override calculateBonus (10%)
- Intern extends Employee: duration, override calculateBonus (5%)

EXERCISE 2: Vehicle Hierarchy
-----------------------------
Create:
- Vehicle (base): brand, model, year, start(), stop(), displayInfo()
- Car extends Vehicle: numberOfDoors, fuelType, honk()
- Motorcycle extends Vehicle: engineCC, hasHelmetStorage
- ElectricCar extends Car: batteryCapacity, chargingTime, charge()

EXERCISE 3: Automation Framework Base
-------------------------------------
Create:
- BaseTest: setUp(), tearDown(), takeScreenshot(), log()
- WebTest extends BaseTest: browserName, navigateTo(), click(), type()
- ApiTest extends BaseTest: baseUri, sendGet(), sendPost(), validateStatus()
- MobileTest extends BaseTest: deviceName, platformName, tap(), swipe()


================================================================================
================================================================================
                    TOPIC 11: POLYMORPHISM IN JAVA
================================================================================
================================================================================

What is Polymorphism?
---------------------
Polymorphism means "many forms". It allows objects to be treated as instances
of their parent class while behaving according to their actual class.

The same method call can produce different behavior depending on the object
that receives the call.


Etymology:
----------
Poly = Many
Morph = Forms
Polymorphism = Many Forms


Real-World Analogy:
-------------------
Think of a "draw()" method:
- If you ask an Artist to draw()  Creates artwork
- If you ask an Architect to draw()  Creates blueprints  
- If you ask a Gun to draw()  Pulls from holster
- If you ask a Curtain to draw()  Opens/closes

Same word "draw", different actions based on WHO is doing it.


Types of Polymorphism:
----------------------
+------------------------+---------------------------+---------------------------+
| Type                   | Also Known As             | When Resolved             |
+------------------------+---------------------------+---------------------------+
| Compile-time           | Static Polymorphism       | During compilation        |
| Polymorphism           | Method Overloading        |                           |
|                        | Early Binding             |                           |
+------------------------+---------------------------+---------------------------+
| Runtime                | Dynamic Polymorphism      | During program execution  |
| Polymorphism           | Method Overriding         |                           |
|                        | Late Binding              |                           |
+------------------------+---------------------------+---------------------------+


Visual Representation:
----------------------

                    POLYMORPHISM
                         |
          +--------------+--------------+
          |                             |
    COMPILE-TIME                   RUNTIME
    (Static)                       (Dynamic)
          |                             |
    Method Overloading            Method Overriding
          |                             |
    - Same class                  - Parent-Child classes
    - Different parameters        - Same parameters
    - Resolved by compiler        - Resolved at runtime
    - Based on arguments          - Based on object type


Why Important for Automation?
-----------------------------
1. Write generic test methods that work with different page objects
2. Create flexible frameworks with interchangeable components
3. Handle different browsers/devices with same interface
4. Process different test data types uniformly
5. Implement strategy patterns for different test approaches


================================================================================
                    1. COMPILE-TIME POLYMORPHISM (METHOD OVERLOADING)
================================================================================

Method Overloading (Recap):
---------------------------
- Same method name, different parameters
- Resolved at compile time
- Can differ in: number of parameters, type of parameters, order of parameters


--------------------------------------------------------------------------------
EXAMPLE 1: Method Overloading - Calculator
--------------------------------------------------------------------------------

class Calculator {
    
    // Overloaded add methods
    
    // Two integers
    public int add(int a, int b) {
        System.out.println("add(int, int) called");
        return a + b;
    }
    
    // Three integers
    public int add(int a, int b, int c) {
        System.out.println("add(int, int, int) called");
        return a + b + c;
    }
    
    // Two doubles
    public double add(double a, double b) {
        System.out.println("add(double, double) called");
        return a + b;
    }
    
    // Integer and double
    public double add(int a, double b) {
        System.out.println("add(int, double) called");
        return a + b;
    }
    
    // Double and integer (different order)
    public double add(double a, int b) {
        System.out.println("add(double, int) called");
        return a + b;
    }
    
    // Array of integers
    public int add(int[] numbers) {
        System.out.println("add(int[]) called");
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    // Varargs
    public int add(int first, int... rest) {
        System.out.println("add(int, int...) called");
        int sum = first;
        for (int num : rest) {
            sum += num;
        }
        return sum;
    }
}

public class CompileTimePolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Compile-Time Polymorphism Demo ===\n");
        
        Calculator calc = new Calculator();
        
        // Compiler determines which method to call based on arguments
        
        System.out.println("Result: " + calc.add(5, 10));
        System.out.println();
        
        System.out.println("Result: " + calc.add(5, 10, 15));
        System.out.println();
        
        System.out.println("Result: " + calc.add(5.5, 10.5));
        System.out.println();
        
        System.out.println("Result: " + calc.add(5, 10.5));
        System.out.println();
        
        System.out.println("Result: " + calc.add(5.5, 10));
        System.out.println();
        
        int[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Result: " + calc.add(numbers));
        System.out.println();
        
        // Note: Varargs method is called when no exact match
        System.out.println("Result: " + calc.add(1, 2, 3, 4, 5, 6, 7));
    }
}

OUTPUT:
-------
=== Compile-Time Polymorphism Demo ===

add(int, int) called
Result: 15

add(int, int, int) called
Result: 30

add(double, double) called
Result: 16.0

add(int, double) called
Result: 15.5

add(double, int) called
Result: 15.5

add(int[]) called
Result: 15

add(int, int...) called
Result: 28


--------------------------------------------------------------------------------
EXAMPLE 2: Method Overloading in Automation Context
--------------------------------------------------------------------------------

class WebElementActions {
    
    // Click with just locator
    public void click(String locator) {
        System.out.println("Clicking element: " + locator);
        // driver.findElement(By.xpath(locator)).click();
    }
    
    // Click with locator type specified
    public void click(String locator, String locatorType) {
        System.out.println("Clicking element [" + locatorType + "]: " + locator);
        // By by = getByType(locatorType, locator);
        // driver.findElement(by).click();
    }
    
    // Click with wait
    public void click(String locator, int waitSeconds) {
        System.out.println("Waiting " + waitSeconds + "s, then clicking: " + locator);
        // WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(waitSeconds));
        // wait.until(ExpectedConditions.elementToBeClickable(By.xpath(locator))).click();
    }
    
    // Click with locator type and wait
    public void click(String locator, String locatorType, int waitSeconds) {
        System.out.println("Waiting " + waitSeconds + "s, then clicking [" + 
                          locatorType + "]: " + locator);
    }
    
    // ===== Type/SendKeys overloaded methods =====
    
    public void type(String locator, String text) {
        System.out.println("Typing '" + text + "' into: " + locator);
    }
    
    public void type(String locator, String text, boolean clearFirst) {
        if (clearFirst) {
            System.out.println("Clearing field: " + locator);
        }
        System.out.println("Typing '" + text + "' into: " + locator);
    }
    
    public void type(String locator, String text, int delayBetweenKeys) {
        System.out.println("Typing '" + text + "' into: " + locator + 
                          " (delay: " + delayBetweenKeys + "ms per key)");
    }
    
    // ===== Wait overloaded methods =====
    
    public void waitForElement(String locator) {
        System.out.println("Waiting for element (default 10s): " + locator);
    }
    
    public void waitForElement(String locator, int seconds) {
        System.out.println("Waiting for element (" + seconds + "s): " + locator);
    }
    
    public void waitForElement(String locator, int seconds, String condition) {
        System.out.println("Waiting for element (" + seconds + "s, " + 
                          condition + "): " + locator);
    }
}

public class AutomationOverloadingDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Automation Method Overloading Demo ===\n");
        
        WebElementActions actions = new WebElementActions();
        
        System.out.println("--- Click Variations ---");
        actions.click("//button[@id='submit']");
        actions.click("submit", "id");
        actions.click("//button[@id='submit']", 5);
        actions.click("submit", "id", 10);
        
        System.out.println("\n--- Type Variations ---");
        actions.type("//input[@id='username']", "testuser");
        actions.type("//input[@id='username']", "testuser", true);
        actions.type("//input[@id='username']", "testuser", 100);
        
        System.out.println("\n--- Wait Variations ---");
        actions.waitForElement("//div[@class='loader']");
        actions.waitForElement("//div[@class='loader']", 30);
        actions.waitForElement("//div[@class='loader']", 30, "invisible");
    }
}

OUTPUT:
-------
=== Automation Method Overloading Demo ===

--- Click Variations ---
Clicking element: //button[@id='submit']
Clicking element [id]: submit
Waiting 5s, then clicking: //button[@id='submit']
Waiting 10s, then clicking [id]: submit

--- Type Variations ---
Typing 'testuser' into: //input[@id='username']
Clearing field: //input[@id='username']
Typing 'testuser' into: //input[@id='username']
Typing 'testuser' into: //input[@id='username'] (delay: 100ms per key)

--- Wait Variations ---
Waiting for element (default 10s): //div[@class='loader']
Waiting for element (30s): //div[@class='loader']
Waiting for element (30s, invisible): //div[@class='loader']


================================================================================
                    2. RUNTIME POLYMORPHISM (METHOD OVERRIDING)
================================================================================

Runtime Polymorphism:
---------------------
- Parent class reference can hold child class object
- Method call is resolved at runtime based on actual object type
- Also called dynamic method dispatch


Key Concept - Upcasting:
------------------------
Parent ref = new Child();    // Upcasting - automatic
                             // ref is Parent type, but points to Child object
                             // Method calls go to Child's overridden methods


Visual Representation:
----------------------
                    MEMORY
    
    Stack                          Heap
    +--------+                     +------------------+
    | ref    | -----------------> | Child Object     |
    | (Parent|                     |                  |
    |  type) |                     | - parent fields  |
    +--------+                     | - child fields   |
                                   | - parent methods |
                                   | - child methods  |
                                   +------------------+
    
    When ref.method() is called:
    - Compiler checks: Does Parent have method()? Yes  Allowed
    - Runtime executes: Child's version of method() (if overridden)


--------------------------------------------------------------------------------
EXAMPLE 3: Basic Runtime Polymorphism
--------------------------------------------------------------------------------

class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void makeSound() {
        System.out.println(name + " makes a sound");
    }
    
    public void eat() {
        System.out.println(name + " is eating");
    }
    
    public void sleep() {
        System.out.println(name + " is sleeping");
    }
}

class Dog extends Animal {
    
    public Dog(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + " says: Woof! Woof!");
    }
    
    @Override
    public void eat() {
        System.out.println(name + " is eating dog food");
    }
    
    // Dog-specific method
    public void fetch() {
        System.out.println(name + " is fetching the ball");
    }
}

class Cat extends Animal {
    
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + " says: Meow!");
    }
    
    @Override
    public void eat() {
        System.out.println(name + " is eating cat food");
    }
    
    // Cat-specific method
    public void scratch() {
        System.out.println(name + " is scratching");
    }
}

class Cow extends Animal {
    
    public Cow(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + " says: Moo!");
    }
    
    // Uses parent's eat() method - no override
}

public class RuntimePolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Runtime Polymorphism Demo ===\n");
        
        // Parent reference, Child objects (Upcasting)
        Animal animal1 = new Dog("Buddy");
        Animal animal2 = new Cat("Whiskers");
        Animal animal3 = new Cow("Bessie");
        Animal animal4 = new Animal("Generic");
        
        System.out.println("--- Calling makeSound() ---");
        System.out.println("(Same method call, different behavior)\n");
        
        animal1.makeSound();    // Dog's makeSound()
        animal2.makeSound();    // Cat's makeSound()
        animal3.makeSound();    // Cow's makeSound()
        animal4.makeSound();    // Animal's makeSound()
        
        System.out.println("\n--- Calling eat() ---\n");
        
        animal1.eat();    // Dog's eat()
        animal2.eat();    // Cat's eat()
        animal3.eat();    // Animal's eat() (Cow didn't override)
        animal4.eat();    // Animal's eat()
        
        System.out.println("\n--- Calling sleep() (not overridden) ---\n");
        
        animal1.sleep();    // Animal's sleep()
        animal2.sleep();    // Animal's sleep()
        
        System.out.println("\n--- Polymorphism with Array ---\n");
        
        Animal[] zoo = {
            new Dog("Rex"),
            new Cat("Luna"),
            new Cow("Daisy"),
            new Dog("Max"),
            new Cat("Simba")
        };
        
        System.out.println("All animals making sounds:");
        for (Animal animal : zoo) {
            animal.makeSound();    // Each calls its own version
        }
        
        System.out.println("\n--- Cannot call child-specific methods ---");
        System.out.println("animal1.fetch(); // Would cause compile error");
        System.out.println("Because 'Animal' type doesn't have fetch() method");
        
        // To call child-specific method, need to downcast
        System.out.println("\n--- Downcasting to access child methods ---");
        if (animal1 instanceof Dog) {
            Dog dog = (Dog) animal1;
            dog.fetch();
        }
    }
}

OUTPUT:
-------
=== Runtime Polymorphism Demo ===

--- Calling makeSound() ---
(Same method call, different behavior)

Buddy says: Woof! Woof!
Whiskers says: Meow!
Bessie says: Moo!
Generic makes a sound

--- Calling eat() ---

Buddy is eating dog food
Whiskers is eating cat food
Bessie is eating
Generic is eating

--- Calling sleep() (not overridden) ---

Buddy is sleeping
Whiskers is sleeping

--- Polymorphism with Array ---

All animals making sounds:
Rex says: Woof! Woof!
Luna says: Meow!
Daisy says: Moo!
Max says: Woof! Woof!
Simba says: Meow!

--- Cannot call child-specific methods ---
animal1.fetch(); // Would cause compile error
Because 'Animal' type doesn't have fetch() method

--- Downcasting to access child methods ---
Buddy is fetching the ball


--------------------------------------------------------------------------------
EXAMPLE 4: Polymorphism - Payment System
--------------------------------------------------------------------------------

// Base class
class Payment {
    protected double amount;
    protected String transactionId;
    
    public Payment(double amount) {
        this.amount = amount;
        this.transactionId = "TXN" + System.currentTimeMillis();
    }
    
    public void processPayment() {
        System.out.println("Processing generic payment of $" + amount);
    }
    
    public void validatePayment() {
        System.out.println("Validating payment...");
        if (amount <= 0) {
            System.out.println("Invalid amount!");
        } else {
            System.out.println("Amount validated: $" + amount);
        }
    }
    
    public void generateReceipt() {
        System.out.println("Receipt for Transaction: " + transactionId);
        System.out.println("Amount: $" + amount);
    }
}

// Credit Card Payment
class CreditCardPayment extends Payment {
    private String cardNumber;
    private String cardHolderName;
    private String expiryDate;
    
    public CreditCardPayment(double amount, String cardNumber, String cardHolderName) {
        super(amount);
        this.cardNumber = maskCardNumber(cardNumber);
        this.cardHolderName = cardHolderName;
    }
    
    private String maskCardNumber(String number) {
        return "****-****-****-" + number.substring(number.length() - 4);
    }
    
    @Override
    public void processPayment() {
        System.out.println("Processing Credit Card payment...");
        System.out.println("Card: " + cardNumber);
        System.out.println("Cardholder: " + cardHolderName);
        System.out.println("Amount: $" + amount);
        System.out.println("Contacting card network...");
        System.out.println("Payment approved!");
    }
    
    @Override
    public void validatePayment() {
        super.validatePayment();
        System.out.println("Validating card details...");
        System.out.println("Card validation successful");
    }
    
    @Override
    public void generateReceipt() {
        super.generateReceipt();
        System.out.println("Payment Method: Credit Card");
        System.out.println("Card: " + cardNumber);
    }
}

// PayPal Payment
class PayPalPayment extends Payment {
    private String email;
    
    public PayPalPayment(double amount, String email) {
        super(amount);
        this.email = email;
    }
    
    @Override
    public void processPayment() {
        System.out.println("Processing PayPal payment...");
        System.out.println("PayPal Account: " + email);
        System.out.println("Amount: $" + amount);
        System.out.println("Redirecting to PayPal...");
        System.out.println("PayPal payment confirmed!");
    }
    
    @Override
    public void validatePayment() {
        super.validatePayment();
        System.out.println("Validating PayPal account...");
        System.out.println("Account verified: " + email);
    }
    
    @Override
    public void generateReceipt() {
        super.generateReceipt();
        System.out.println("Payment Method: PayPal");
        System.out.println("Account: " + email);
    }
}

// Bank Transfer Payment
class BankTransferPayment extends Payment {
    private String bankName;
    private String accountNumber;
    private String routingNumber;
    
    public BankTransferPayment(double amount, String bankName, String accountNumber) {
        super(amount);
        this.bankName = bankName;
        this.accountNumber = maskAccountNumber(accountNumber);
    }
    
    private String maskAccountNumber(String number) {
        return "****" + number.substring(number.length() - 4);
    }
    
    @Override
    public void processPayment() {
        System.out.println("Processing Bank Transfer...");
        System.out.println("Bank: " + bankName);
        System.out.println("Account: " + accountNumber);
        System.out.println("Amount: $" + amount);
        System.out.println("Initiating ACH transfer...");
        System.out.println("Transfer initiated (2-3 business days)");
    }
    
    @Override
    public void validatePayment() {
        super.validatePayment();
        System.out.println("Validating bank account...");
        System.out.println("Bank account verified");
    }
    
    @Override
    public void generateReceipt() {
        super.generateReceipt();
        System.out.println("Payment Method: Bank Transfer");
        System.out.println("Bank: " + bankName);
        System.out.println("Account: " + accountNumber);
    }
}

// Cryptocurrency Payment
class CryptoPayment extends Payment {
    private String walletAddress;
    private String cryptoType;
    private double cryptoAmount;
    
    public CryptoPayment(double amount, String walletAddress, String cryptoType) {
        super(amount);
        this.walletAddress = walletAddress;
        this.cryptoType = cryptoType;
        this.cryptoAmount = convertToCrypto(amount, cryptoType);
    }
    
    private double convertToCrypto(double usdAmount, String type) {
        // Simulated conversion rates
        switch (type.toUpperCase()) {
            case "BTC": return usdAmount / 45000;
            case "ETH": return usdAmount / 3000;
            default: return usdAmount;
        }
    }
    
    @Override
    public void processPayment() {
        System.out.println("Processing Cryptocurrency payment...");
        System.out.println("Crypto: " + cryptoType);
        System.out.println("Wallet: " + walletAddress.substring(0, 10) + "...");
        System.out.println("Amount: " + String.format("%.6f", cryptoAmount) + " " + cryptoType);
        System.out.println("USD Equivalent: $" + amount);
        System.out.println("Broadcasting to blockchain...");
        System.out.println("Transaction submitted!");
    }
    
    @Override
    public void generateReceipt() {
        super.generateReceipt();
        System.out.println("Payment Method: Cryptocurrency");
        System.out.println("Crypto: " + cryptoType);
        System.out.println("Amount: " + String.format("%.6f", cryptoAmount) + " " + cryptoType);
    }
}

// Payment Processor - demonstrates polymorphism
class PaymentProcessor {
    
    // This method accepts ANY type of Payment
    public void process(Payment payment) {
        System.out.println("\n" + "=".repeat(50));
        System.out.println("PAYMENT PROCESSOR");
        System.out.println("=".repeat(50));
        
        payment.validatePayment();
        System.out.println();
        
        payment.processPayment();
        System.out.println();
        
        payment.generateReceipt();
        System.out.println("=".repeat(50));
    }
    
    // Process multiple payments
    public void processAll(Payment[] payments) {
        System.out.println("\n" + "#".repeat(50));
        System.out.println("BATCH PAYMENT PROCESSING");
        System.out.println("#".repeat(50));
        
        for (int i = 0; i < payments.length; i++) {
            System.out.println("\nProcessing Payment " + (i + 1) + " of " + payments.length);
            process(payments[i]);
        }
        
        System.out.println("\n" + "#".repeat(50));
        System.out.println("BATCH PROCESSING COMPLETE");
        System.out.println("#".repeat(50));
    }
}

public class PaymentPolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Payment System Polymorphism Demo ===");
        
        PaymentProcessor processor = new PaymentProcessor();
        
        // Create different payment types
        Payment creditCard = new CreditCardPayment(150.00, "[REDACTED:CREDIT_DEBIT_NUMBER]", "John Doe");
        Payment paypal = new PayPalPayment(75.50, "john.doe@email.com");
        Payment bankTransfer = new BankTransferPayment(500.00, "Chase Bank", "[REDACTED:BANK_ACCOUNT_NUMBER]");
        Payment crypto = new CryptoPayment(1000.00, "0x742d35Cc6634C0532925a3b844Bc9e7595f", "ETH");
        
        // Process individual payment
        processor.process(creditCard);
        
        // Process batch - demonstrates polymorphism with array
        Payment[] allPayments = {creditCard, paypal, bankTransfer, crypto};
        processor.processAll(allPayments);
    }
}

OUTPUT:
-------
=== Payment System Polymorphism Demo ===

==================================================
PAYMENT PROCESSOR
==================================================
Validating payment...
Amount validated: $150.0
Validating card details...
Card validation successful

Processing Credit Card payment...
Card: ****-****-****-0366
Cardholder: John Doe
Amount: $150.0
Contacting card network...
Payment approved!

Receipt for Transaction: TXN1234567890123
Amount: $150.0
Payment Method: Credit Card
Card: ****-****-****-0366
==================================================

##################################################
BATCH PAYMENT PROCESSING
##################################################

Processing Payment 1 of 4

==================================================
PAYMENT PROCESSOR
==================================================
Validating payment...
Amount validated: $150.0
Validating card details...
Card validation successful

Processing Credit Card payment...
Card: ****-****-****-0366
Cardholder: John Doe
Amount: $150.0
Contacting card network...
Payment approved!

Receipt for Transaction: TXN1234567890123
Amount: $150.0
Payment Method: Credit Card
Card: ****-****-****-0366
==================================================

Processing Payment 2 of 4

==================================================
PAYMENT PROCESSOR
==================================================
Validating payment...
Amount validated: $75.5
Validating PayPal account...
Account verified: john.doe@email.com

Processing PayPal payment...
PayPal Account: john.doe@email.com
Amount: $75.5
Redirecting to PayPal...
PayPal payment confirmed!

Receipt for Transaction: TXN1234567890124
Amount: $75.5
Payment Method: PayPal
Account: john.doe@email.com
==================================================

... (continues for other payments)


================================================================================
                    3. POLYMORPHISM IN AUTOMATION TESTING
================================================================================

--------------------------------------------------------------------------------
EXAMPLE 5: Browser Driver Polymorphism
--------------------------------------------------------------------------------

// Base class for all browser drivers
class BrowserDriver {
    protected String browserName;
    protected boolean isHeadless;
    
    public BrowserDriver() {
        this.browserName = "Unknown";
        this.isHeadless = false;
    }
    
    public void launch() {
        System.out.println("Launching " + browserName + " browser...");
    }
    
    public void navigateTo(String url) {
        System.out.println("[" + browserName + "] Navigating to: " + url);
    }
    
    public void maximize() {
        System.out.println("[" + browserName + "] Maximizing window");
    }
    
    public void close() {
        System.out.println("[" + browserName + "] Closing browser");
    }
    
    public void quit() {
        System.out.println("[" + browserName + "] Quitting browser and closing all windows");
    }
    
    public void takeScreenshot(String fileName) {
        System.out.println("[" + browserName + "] Taking screenshot: " + fileName);
    }
    
    public String getBrowserName() {
        return browserName;
    }
}

// Chrome Driver
class ChromeBrowser extends BrowserDriver {
    private String chromeDriverPath;
    
    public ChromeBrowser() {
        this.browserName = "Chrome";
        this.chromeDriverPath = "/drivers/chromedriver";
    }
    
    public ChromeBrowser(boolean headless) {
        this();
        this.isHeadless = headless;
    }
    
    @Override
    public void launch() {
        System.out.println("Setting ChromeDriver path: " + chromeDriverPath);
        if (isHeadless) {
            System.out.println("Configuring Chrome in headless mode");
        }
        System.out.println("Launching Chrome browser...");
        System.out.println("Chrome launched successfully!");
    }
    
    @Override
    public void takeScreenshot(String fileName) {
        System.out.println("[Chrome] Using ChromeDriver screenshot capability");
        System.out.println("[Chrome] Screenshot saved: " + fileName + ".png");
    }
    
    // Chrome-specific method
    public void enableDevTools() {
        System.out.println("[Chrome] Enabling DevTools Protocol");
    }
}

// Firefox Driver
class FirefoxBrowser extends BrowserDriver {
    private String geckoDriverPath;
    
    public FirefoxBrowser() {
        this.browserName = "Firefox";
        this.geckoDriverPath = "/drivers/geckodriver";
    }
    
    public FirefoxBrowser(boolean headless) {
        this();
        this.isHeadless = headless;
    }
    
    @Override
    public void launch() {
        System.out.println("Setting GeckoDriver path: " + geckoDriverPath);
        if (isHeadless) {
            System.out.println("Configuring Firefox in headless mode");
        }
        System.out.println("Launching Firefox browser...");
        System.out.println("Firefox launched successfully!");
    }
    
    @Override
    public void takeScreenshot(String fileName) {
        System.out.println("[Firefox] Using GeckoDriver screenshot capability");
        System.out.println("[Firefox] Screenshot saved: " + fileName + ".png");
    }
    
    // Firefox-specific method
    public void setProfile(String profileName) {
        System.out.println("[Firefox] Setting profile: " + profileName);
    }
}

// Edge Driver
class EdgeBrowser extends BrowserDriver {
    private String edgeDriverPath;
    
    public EdgeBrowser() {
        this.browserName = "Edge";
        this.edgeDriverPath = "/drivers/msedgedriver";
    }
    
    @Override
    public void launch() {
        System.out.println("Setting EdgeDriver path: " + edgeDriverPath);
        System.out.println("Launching Microsoft Edge browser...");
        System.out.println("Edge launched successfully!");
    }
    
    @Override
    public void takeScreenshot(String fileName) {
        System.out.println("[Edge] Using EdgeDriver screenshot capability");
        System.out.println("[Edge] Screenshot saved: " + fileName + ".png");
    }
}

// Safari Driver
class SafariBrowser extends BrowserDriver {
    
    public SafariBrowser() {
        this.browserName = "Safari";
    }
    
    @Override
    public void launch() {
        System.out.println("Safari uses built-in driver");
        System.out.println("Enabling Safari automation in Develop menu...");
        System.out.println("Launching Safari browser...");
        System.out.println("Safari launched successfully!");
    }
    
    @Override
    public void takeScreenshot(String fileName) {
        System.out.println("[Safari] Using SafariDriver screenshot capability");
        System.out.println("[Safari] Screenshot saved: " + fileName + ".png");
    }
}

// Browser Factory - creates appropriate browser based on input
class BrowserFactory {
    
    public static BrowserDriver getBrowser(String browserType) {
        return getBrowser(browserType, false);
    }
    
    public static BrowserDriver getBrowser(String browserType, boolean headless) {
        switch (browserType.toLowerCase()) {
            case "chrome":
                return new ChromeBrowser(headless);
            case "firefox":
                return new FirefoxBrowser(headless);
            case "edge":
                return new EdgeBrowser();
            case "safari":
                return new SafariBrowser();
            default:
                System.out.println("Unknown browser, defaulting to Chrome");
                return new ChromeBrowser();
        }
    }
}

// Test class that uses polymorphism
class CrossBrowserTest {
    private BrowserDriver driver;    // Parent type reference
    
    public void setDriver(BrowserDriver driver) {
        this.driver = driver;
    }
    
    public void runTest() {
        System.out.println("\n" + "-".repeat(50));
        System.out.println("Running test on: " + driver.getBrowserName());
        System.out.println("-".repeat(50));
        
        driver.launch();
        driver.maximize();
        driver.navigateTo("https://example.com");
        
        // Perform test actions
        System.out.println("[Test] Performing test actions...");
        System.out.println("[Test] Clicking login button");
        System.out.println("[Test] Entering credentials");
        System.out.println("[Test] Verifying dashboard");
        
        driver.takeScreenshot("test_result");
        driver.quit();
        
        System.out.println("[Test] Test completed on " + driver.getBrowserName());
    }
}

public class BrowserPolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=".repeat(60));
        System.out.println("       CROSS-BROWSER TESTING WITH POLYMORPHISM");
        System.out.println("=".repeat(60));
        
        CrossBrowserTest test = new CrossBrowserTest();
        
        // Run same test on different browsers
        String[] browsers = {"chrome", "firefox", "edge", "safari"};
        
        for (String browserName : browsers) {
            // Factory returns appropriate browser - polymorphism in action!
            BrowserDriver browser = BrowserFactory.getBrowser(browserName);
            test.setDriver(browser);
            test.runTest();
        }
        
        System.out.println("\n" + "=".repeat(60));
        System.out.println("       ALL BROWSER TESTS COMPLETED");
        System.out.println("=".repeat(60));
    }
}

OUTPUT:
-------
============================================================
       CROSS-BROWSER TESTING WITH POLYMORPHISM
============================================================

--------------------------------------------------
Running test on: Chrome
--------------------------------------------------
Setting ChromeDriver path: /drivers/chromedriver
Launching Chrome browser...
Chrome launched successfully!
[Chrome] Maximizing window
[Chrome] Navigating to: https://example.com
[Test] Performing test actions...
[Test] Clicking login button
[Test] Entering credentials
[Test] Verifying dashboard
[Chrome] Using ChromeDriver screenshot capability
[Chrome] Screenshot saved: test_result.png
[Chrome] Quitting browser and closing all windows
[Test] Test completed on Chrome

--------------------------------------------------
Running test on: Firefox
--------------------------------------------------
Setting GeckoDriver path: /drivers/geckodriver
Launching Firefox browser...
Firefox launched successfully!
[Firefox] Maximizing window
[Firefox] Navigating to: https://example.com
[Test] Performing test actions...
[Test] Clicking login button
[Test] Entering credentials
[Test] Verifying dashboard
[Firefox] Using GeckoDriver screenshot capability
[Firefox] Screenshot saved: test_result.png
[Firefox] Quitting browser and closing all windows
[Test] Test completed on Firefox

--------------------------------------------------
Running test on: Edge
--------------------------------------------------
Setting EdgeDriver path: /drivers/msedgedriver
Launching Microsoft Edge browser...
Edge launched successfully!
[Edge] Maximizing window
[Edge] Navigating to: https://example.com
[Test] Performing test actions...
[Test] Clicking login button
[Test] Entering credentials
[Test] Verifying dashboard
[Edge] Using EdgeDriver screenshot capability
[Edge] Screenshot saved: test_result.png
[Edge] Quitting browser and closing all windows
[Test] Test completed on Edge

--------------------------------------------------
Running test on: Safari
--------------------------------------------------
Safari uses built-in driver
Enabling Safari automation in Develop menu...
Launching Safari browser...
Safari launched successfully!
[Safari] Maximizing window
[Safari] Navigating to: https://example.com
[Test] Performing test actions...
[Test] Clicking login button
[Test] Entering credentials
[Test] Verifying dashboard
[Safari] Using SafariDriver screenshot capability
[Safari] Screenshot saved: test_result.png
[Safari] Quitting browser and closing all windows
[Test] Test completed on Safari

============================================================
       ALL BROWSER TESTS COMPLETED
============================================================


--------------------------------------------------------------------------------
EXAMPLE 6: Page Object Polymorphism
--------------------------------------------------------------------------------

// Base Page class
class BasePage {
    protected String pageName;
    protected String pageUrl;
    
    public BasePage(String pageName, String pageUrl) {
        this.pageName = pageName;
        this.pageUrl = pageUrl;
    }
    
    public void load() {
        System.out.println("Loading page: " + pageName);
        System.out.println("URL: " + pageUrl);
    }
    
    public boolean isLoaded() {
        System.out.println("Checking if " + pageName + " is loaded...");
        return true;
    }
    
    public void waitForPageLoad() {
        System.out.println("Waiting for " + pageName + " to load...");
    }
    
    public String getPageTitle() {
        return pageName;
    }
}

// Login Page
class LoginPagePoly extends BasePage {
    
    public LoginPagePoly() {
        super("Login Page", "https://app.example.com/login");
    }
    
    @Override
    public void load() {
        super.load();
        System.out.println("[LoginPage] Checking for login form...");
    }
    
    @Override
    public boolean isLoaded() {
        System.out.println("[LoginPage] Verifying login form elements...");
        System.out.println("[LoginPage] - Username field present");
        System.out.println("[LoginPage] - Password field present");
        System.out.println("[LoginPage] - Login button present");
        return true;
    }
    
    public void login(String username, String password) {
        System.out.println("[LoginPage] Entering username: " + username);
        System.out.println("[LoginPage] Entering password: ****");
        System.out.println("[LoginPage] Clicking login button");
    }
}

// Dashboard Page
class DashboardPagePoly extends BasePage {
    
    public DashboardPagePoly() {
        super("Dashboard", "https://app.example.com/dashboard");
    }
    
    @Override
    public void load() {
        super.load();
        System.out.println("[Dashboard] Loading dashboard widgets...");
    }
    
    @Override
    public boolean isLoaded() {
        System.out.println("[Dashboard] Verifying dashboard elements...");
        System.out.println("[Dashboard] - Welcome message present");
        System.out.println("[Dashboard] - Navigation menu present");
        System.out.println("[Dashboard] - Dashboard widgets loaded");
        return true;
    }
    
    public void clickMenuItem(String item) {
        System.out.println("[Dashboard] Clicking menu item: " + item);
    }
}

// Products Page
class ProductsPagePoly extends BasePage {
    
    public ProductsPagePoly() {
        super("Products Page", "https://app.example.com/products");
    }
    
    @Override
    public void load() {
        super.load();
        System.out.println("[Products] Loading product catalog...");
    }
    
    @Override
    public boolean isLoaded() {
        System.out.println("[Products] Verifying products page elements...");
        System.out.println("[Products] - Product grid present");
        System.out.println("[Products] - Filter sidebar present");
        System.out.println("[Products] - Search box present");
        return true;
    }
    
    public void searchProduct(String productName) {
        System.out.println("[Products] Searching for: " + productName);
    }
}

// Checkout Page
class CheckoutPagePoly extends BasePage {
    
    public CheckoutPagePoly() {
        super("Checkout Page", "https://app.example.com/checkout");
    }
    
    @Override
    public void load() {
        super.load();
        System.out.println("[Checkout] Loading checkout form...");
    }
    
    @Override
    public boolean isLoaded() {
        System.out.println("[Checkout] Verifying checkout page elements...");
        System.out.println("[Checkout] - Cart summary present");
        System.out.println("[Checkout] - Payment form present");
        System.out.println("[Checkout] - Place order button present");
        return true;
    }
    
    public void enterPaymentDetails(String cardNumber) {
        System.out.println("[Checkout] Entering payment details...");
    }
}

// Page Navigator - uses polymorphism
class PageNavigator {
    
    // Generic method that works with any page
    public void navigateToPage(BasePage page) {
        System.out.println("\n" + "=".repeat(50));
        System.out.println("NAVIGATING TO: " + page.getPageTitle());
        System.out.println("=".repeat(50));
        
        page.load();
        page.waitForPageLoad();
        
        if (page.isLoaded()) {
            System.out.println(" Page loaded successfully!");
        } else {
            System.out.println(" Page failed to load!");
        }
    }
    
    // Verify multiple pages
    public void verifyAllPages(BasePage[] pages) {
        System.out.println("\n" + "#".repeat(50));
        System.out.println("VERIFYING ALL PAGES");
        System.out.println("#".repeat(50));
        
        int passed = 0;
        int failed = 0;
        
        for (BasePage page : pages) {
            navigateToPage(page);
            if (page.isLoaded()) {
                passed++;
            } else {
                failed++;
            }
        }
        
        System.out.println("\n" + "#".repeat(50));
        System.out.println("VERIFICATION COMPLETE");
        System.out.println("Passed: " + passed + ", Failed: " + failed);
        System.out.println("#".repeat(50));
    }
}

public class PageObjectPolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Page Object Polymorphism Demo ===\n");
        
        PageNavigator navigator = new PageNavigator();
        
        // Create different page objects
        BasePage loginPage = new LoginPagePoly();
        BasePage dashboard = new DashboardPagePoly();
        BasePage products = new ProductsPagePoly();
        BasePage checkout = new CheckoutPagePoly();
        
        // Navigate to single page
        navigator.navigateToPage(loginPage);
        
        // Verify all pages - polymorphism in action
        BasePage[] allPages = {loginPage, dashboard, products, checkout};
        navigator.verifyAllPages(allPages);
    }
}


--------------------------------------------------------------------------------
EXAMPLE 7: Test Data Polymorphism
--------------------------------------------------------------------------------

// Base test data class
class TestData {
    protected String testName;
    protected String dataSource;
    
    public TestData(String testName) {
        this.testName = testName;
        this.dataSource = "Unknown";
    }
    
    public void loadData() {
        System.out.println("Loading test data for: " + testName);
    }
    
    public String getData(String key) {
        return "default_value";
    }
    
    public void printDataSource() {
        System.out.println("Data source: " + dataSource);
    }
}

// Excel Test Data
class ExcelTestData extends TestData {
    private String filePath;
    private String sheetName;
    
    public ExcelTestData(String testName, String filePath, String sheetName) {
        super(testName);
        this.filePath = filePath;
        this.sheetName = sheetName;
        this.dataSource = "Excel";
    }
    
    @Override
    public void loadData() {
        System.out.println("[Excel] Loading data from: " + filePath);
        System.out.println("[Excel] Sheet: " + sheetName);
        System.out.println("[Excel] Data loaded successfully!");
    }
    
    @Override
    public String getData(String key) {
        System.out.println("[Excel] Reading cell for key: " + key);
        return "excel_value_for_" + key;
    }
}

// JSON Test Data
class JsonTestData extends TestData {
    private String jsonFilePath;
    
    public JsonTestData(String testName, String jsonFilePath) {
        super(testName);
        this.jsonFilePath = jsonFilePath;
        this.dataSource = "JSON";
    }
    
    @Override
    public void loadData() {
        System.out.println("[JSON] Loading data from: " + jsonFilePath);
        System.out.println("[JSON] Parsing JSON structure...");
        System.out.println("[JSON] Data loaded successfully!");
    }
    
    @Override
    public String getData(String key) {
        System.out.println("[JSON] Reading JSON path: $." + key);
        return "json_value_for_" + key;
    }
}

// Database Test Data
class DatabaseTestData extends TestData {
    private String connectionString;
    private String query;
    
    public DatabaseTestData(String testName, String connectionString) {
        super(testName);
        this.connectionString = connectionString;
        this.dataSource = "Database";
    }
    
    @Override
    public void loadData() {
        System.out.println("[DB] Connecting to: " + connectionString);
        System.out.println("[DB] Connection established!");
        System.out.println("[DB] Data loaded successfully!");
    }
    
    @Override
    public String getData(String key) {
        System.out.println("[DB] Executing query for: " + key);
        return "db_value_for_" + key;
    }
}

// Properties File Test Data
class PropertiesTestData extends TestData {
    private String propertiesFile;
    
    public PropertiesTestData(String testName, String propertiesFile) {
        super(testName);
        this.propertiesFile = propertiesFile;
        this.dataSource = "Properties";
    }
    
    @Override
    public void loadData() {
        System.out.println("[Properties] Loading: " + propertiesFile);
        System.out.println("[Properties] Properties loaded successfully!");
    }
    
    @Override
    public String getData(String key) {
        System.out.println("[Properties] Reading property: " + key);
        return "property_value_for_" + key;
    }
}

// Test that uses data polymorphically
class DataDrivenTest {
    private TestData testData;    // Parent type reference
    
    public DataDrivenTest(TestData testData) {
        this.testData = testData;
    }
    
    public void runTest() {
        System.out.println("\n" + "-".repeat(50));
        System.out.println("Running Data-Driven Test");
        testData.printDataSource();
        System.out.println("-".repeat(50));
        
        // Load data - calls appropriate subclass method
        testData.loadData();
        
        // Get test data - calls appropriate subclass method
        String username = testData.getData("username");
        String password = testData.getData("password");
        String url = testData.getData("url");
        
        System.out.println("\nRetrieved test data:");
        System.out.println("  Username: " + username);
        System.out.println("  Password: " + password);
        System.out.println("  URL: " + url);
        
        System.out.println("\nExecuting test with retrieved data...");
        System.out.println("Test completed!");
    }
}

public class TestDataPolymorphismDemo {
    public static void main(String[] args) {
        
        System.out.println("=".repeat(60));
        System.out.println("       TEST DATA POLYMORPHISM DEMO");
        System.out.println("=".repeat(60));
        
        // Create different data sources
        TestData excelData = new ExcelTestData("LoginTest", "testdata.xlsx", "Sheet1");
        TestData jsonData = new JsonTestData("LoginTest", "testdata.json");
        TestData dbData = new DatabaseTestData("LoginTest", "jdbc:mysql://localhost/testdb");
        TestData propData = new PropertiesTestData("LoginTest", "config.properties");
        
        // Run same test with different data sources
        TestData[] dataSources = {excelData, jsonData, dbData, propData};
        
        for (TestData data : dataSources) {
            DataDrivenTest test = new DataDrivenTest(data);
            test.runTest();
        }
    }
}


================================================================================
                    4. UPCASTING AND DOWNCASTING
================================================================================

Upcasting:
----------
- Converting child reference to parent reference
- Always safe and automatic
- Syntax: Parent p = new Child();

Downcasting:
------------
- Converting parent reference back to child reference
- Requires explicit cast
- Can cause ClassCastException if object is not actually that type
- Always use instanceof before downcasting


Visual Representation:
----------------------

    UPCASTING (Automatic - Safe)
    
    Child obj > Parent ref
    (more specific)             (more general)
    
    Dog dog = new Dog();
    Animal animal = dog;    // Upcasting
    
    
    DOWNCASTING (Manual - Risky)
    
    Parent ref > Child obj
    (more general)              (more specific)
    
    Animal animal = new Dog();
    Dog dog = (Dog) animal;    // Downcasting - need explicit cast


--------------------------------------------------------------------------------
EXAMPLE 8: Upcasting and Downcasting
--------------------------------------------------------------------------------

class Vehicle {
    protected String brand;
    
    public Vehicle(String brand) {
        this.brand = brand;
    }
    
    public void start() {
        System.out.println(brand + " vehicle starting...");
    }
    
    public void stop() {
        System.out.println(brand + " vehicle stopping...");
    }
}

class Car extends Vehicle {
    private int doors;
    
    public Car(String brand, int doors) {
        super(brand);
        this.doors = doors;
    }
    
    @Override
    public void start() {
        System.out.println(brand + " car starting with key ignition...");
    }
    
    public void honk() {
        System.out.println(brand + " car honking: Beep Beep!");
    }
    
    public void openTrunk() {
        System.out.println(brand + " opening trunk...");
    }
}

class Motorcycle extends Vehicle {
    private int engineCC;
    
    public Motorcycle(String brand, int engineCC) {
        super(brand);
        this.engineCC = engineCC;
    }
    
    @Override
    public void start() {
        System.out.println(brand + " motorcycle starting with kick/button...");
    }
    
    public void wheelie() {
        System.out.println(brand + " " + engineCC + "cc doing a wheelie!");
    }
    
    public void revEngine() {
        System.out.println(brand + " revving engine: Vroom Vroom!");
    }
}

class Truck extends Vehicle {
    private double loadCapacity;
    
    public Truck(String brand, double loadCapacity) {
        super(brand);
        this.loadCapacity = loadCapacity;
    }
    
    @Override
    public void start() {
        System.out.println(brand + " truck starting with diesel engine...");
    }
    
    public void loadCargo() {
        System.out.println(brand + " loading cargo (capacity: " + loadCapacity + " tons)");
    }
    
    public void honkLoud() {
        System.out.println(brand + " truck horn: HOOOONK!");
    }
}

public class CastingDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Upcasting and Downcasting Demo ===\n");
        
        // ===== UPCASTING (Automatic) =====
        System.out.println("--- UPCASTING (Child to Parent) ---\n");
        
        Car car = new Car("Toyota", 4);
        Motorcycle motorcycle = new Motorcycle("Honda", 600);
        Truck truck = new Truck("Ford", 5.0);
        
        // Upcasting - automatic, no cast needed
        Vehicle vehicle1 = car;           // Car -> Vehicle
        Vehicle vehicle2 = motorcycle;    // Motorcycle -> Vehicle
        Vehicle vehicle3 = truck;         // Truck -> Vehicle
        
        System.out.println("After upcasting, calling start():");
        vehicle1.start();    // Calls Car's start() - polymorphism!
        vehicle2.start();    // Calls Motorcycle's start()
        vehicle3.start();    // Calls Truck's start()
        
        System.out.println("\nNote: Cannot call child-specific methods after upcasting:");
        System.out.println("vehicle1.honk();     // Compile error - Vehicle has no honk()");
        System.out.println("vehicle2.wheelie();  // Compile error - Vehicle has no wheelie()");
        
        
        // ===== DOWNCASTING (Manual) =====
        System.out.println("\n--- DOWNCASTING (Parent to Child) ---\n");
        
        // Safe downcasting with instanceof
        if (vehicle1 instanceof Car) {
            Car downcastedCar = (Car) vehicle1;
            System.out.println("Successfully downcasted to Car!");
            downcastedCar.honk();
            downcastedCar.openTrunk();
        }
        
        if (vehicle2 instanceof Motorcycle) {
            Motorcycle downcastedBike = (Motorcycle) vehicle2;
            System.out.println("\nSuccessfully downcasted to Motorcycle!");
            downcastedBike.wheelie();
            downcastedBike.revEngine();
        }
        
        if (vehicle3 instanceof Truck) {
            Truck downcastedTruck = (Truck) vehicle3;
            System.out.println("\nSuccessfully downcasted to Truck!");
            downcastedTruck.loadCargo();
            downcastedTruck.honkLoud();
        }
        
        
        // ===== WRONG DOWNCASTING (Would cause ClassCastException) =====
        System.out.println("\n--- PREVENTING ClassCastException ---\n");
        
        Vehicle someVehicle = new Car("BMW", 2);    // Actually a Car
        
        // Check before casting
        System.out.println("Is someVehicle a Car? " + (someVehicle instanceof Car));
        System.out.println("Is someVehicle a Motorcycle? " + (someVehicle instanceof Motorcycle));
        System.out.println("Is someVehicle a Truck? " + (someVehicle instanceof Truck));
        
        // Safe casting
        if (someVehicle instanceof Motorcycle) {
            Motorcycle m = (Motorcycle) someVehicle;
            m.wheelie();
        } else {
            System.out.println("\nCannot cast to Motorcycle - would cause ClassCastException!");
        }
        
        
        // ===== POLYMORPHIC ARRAY WITH DOWNCASTING =====
        System.out.println("\n--- PROCESSING MIXED VEHICLES ---\n");
        
        Vehicle[] fleet = {
            new Car("Mercedes", 4),
            new Motorcycle("Yamaha", 1000),
            new Truck("Volvo", 10.0),
            new Car("Audi", 2),
            new Motorcycle("Ducati", 800)
        };
        
        for (int i = 0; i < fleet.length; i++) {
            System.out.println("Vehicle " + (i + 1) + ":");
            fleet[i].start();    // Polymorphic call
            
            // Call specific methods based on type
            if (fleet[i] instanceof Car) {
                ((Car) fleet[i]).honk();
            } else if (fleet[i] instanceof Motorcycle) {
                ((Motorcycle) fleet[i]).revEngine();
            } else if (fleet[i] instanceof Truck) {
                ((Truck) fleet[i]).honkLoud();
            }
            System.out.println();
        }
    }
}

OUTPUT:
-------
=== Upcasting and Downcasting Demo ===

--- UPCASTING (Child to Parent) ---

After upcasting, calling start():
Toyota car starting with key ignition...
Honda motorcycle starting with kick/button...
Ford truck starting with diesel engine...

Note: Cannot call child-specific methods after upcasting:
vehicle1.honk();     // Compile error - Vehicle has no honk()
vehicle2.wheelie();  // Compile error - Vehicle has no wheelie()

--- DOWNCASTING (Parent to Child) ---

Successfully downcasted to Car!
Toyota car honking: Beep Beep!
Toyota opening trunk...

Successfully downcasted to Motorcycle!
Honda 600cc doing a wheelie!
Honda revving engine: Vroom Vroom!

Successfully downcasted to Truck!
Ford loading cargo (capacity: 5.0 tons)
Ford truck horn: HOOOONK!

--- PREVENTING ClassCastException ---

Is someVehicle a Car? true
Is someVehicle a Motorcycle? false
Is someVehicle a Truck? false

Cannot cast to Motorcycle - would cause ClassCastException!

--- PROCESSING MIXED VEHICLES ---

Vehicle 1:
Mercedes car starting with key ignition...
Mercedes car honking: Beep Beep!

Vehicle 2:
Yamaha motorcycle starting with kick/button...
Yamaha revving engine: Vroom Vroom!

Vehicle 3:
Volvo truck starting with diesel engine...
Volvo truck horn: HOOOONK!

Vehicle 4:
Audi car starting with key ignition...
Audi car honking: Beep Beep!

Vehicle 5:
Ducati motorcycle starting with kick/button...
Ducati revving engine: Vroom Vroom!


================================================================================
                    5. COVARIANT RETURN TYPES
================================================================================

What is Covariant Return Type?
------------------------------
When overriding a method, the return type can be a subtype of the original
return type. This is called covariant return type.

Example:
- Parent method returns: Animal
- Child method can return: Dog (because Dog IS-A Animal)


--------------------------------------------------------------------------------
EXAMPLE 9: Covariant Return Types
--------------------------------------------------------------------------------

class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void speak() {
        System.out.println(name + " makes a sound");
    }
}

class Dog extends Animal {
    private String breed;
    
    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }
    
    @Override
    public void speak() {
        System.out.println(name + " barks: Woof!");
    }
    
    public void fetch() {
        System.out.println(name + " fetches the ball!");
    }
    
    public String getBreed() {
        return breed;
    }
}

class Cat extends Animal {
    private boolean isIndoor;
    
    public Cat(String name, boolean isIndoor) {
        super(name);
        this.isIndoor = isIndoor;
    }
    
    @Override
    public void speak() {
        System.out.println(name + " meows: Meow!");
    }
    
    public void scratch() {
        System.out.println(name + " scratches!");
    }
}

// Animal Shelter - demonstrates covariant return types
class AnimalShelter {
    
    // Returns Animal type
    public Animal adoptAnimal() {
        System.out.println("[Shelter] Adopting a generic animal");
        return new Animal("Generic");
    }
}

// Dog Shelter - covariant return type
class DogShelter extends AnimalShelter {
    
    // Covariant return type: Dog instead of Animal
    @Override
    public Dog adoptAnimal() {
        System.out.println("[DogShelter] Adopting a dog");
        return new Dog("Buddy", "Golden Retriever");
    }
    
    // Additional method
    public Dog adoptPuppy() {
        System.out.println("[DogShelter] Adopting a puppy");
        return new Dog("Puppy", "Labrador");
    }
}

// Cat Shelter - covariant return type
class CatShelter extends AnimalShelter {
    
    // Covariant return type: Cat instead of Animal
    @Override
    public Cat adoptAnimal() {
        System.out.println("[CatShelter] Adopting a cat");
        return new Cat("Whiskers", true);
    }
}

public class CovariantReturnDemo {
    public static void main(String[] args) {
        
        System.out.println("=== Covariant Return Types Demo ===\n");
        
        // Using parent type reference
        AnimalShelter shelter1 = new AnimalShelter();
        AnimalShelter shelter2 = new DogShelter();
        AnimalShelter shelter3 = new CatShelter();
        
        System.out.println("--- Adopting from different shelters ---\n");
        
        Animal animal1 = shelter1.adoptAnimal();
        animal1.speak();
        
        System.out.println();
        
        Animal animal2 = shelter2.adoptAnimal();    // Returns Dog but stored as Animal
        animal2.speak();
        
        System.out.println();
        
        Animal animal3 = shelter3.adoptAnimal();    // Returns Cat but stored as Animal
        animal3.speak();
        
        System.out.println("\n--- Benefit of covariant return types ---\n");
        
        // Using child type reference - can access child-specific methods directly
        DogShelter dogShelter = new DogShelter();
        Dog dog = dogShelter.adoptAnimal();    // Returns Dog type directly!
        
        dog.speak();
        dog.fetch();    // Can call Dog-specific method without casting!
        System.out.println("Breed: " + dog.getBreed());
        
        System.out.println();
        
        CatShelter catShelter = new CatShelter();
        Cat cat = catShelter.adoptAnimal();    // Returns Cat type directly!
        
        cat.speak();
        cat.scratch();    // Can call Cat-specific method without casting!
    }
}

OUTPUT:
-------
=== Covariant Return Types Demo ===

--- Adopting from different shelters ---

[Shelter] Adopting a generic animal
Generic makes a sound

[DogShelter] Adopting a dog
Buddy barks: Woof!

[CatShelter] Adopting a cat
Whiskers meows: Meow!

--- Benefit of covariant return types ---

[DogShelter] Adopting a dog
Buddy barks: Woof!
Buddy fetches the ball!
Breed: Golden Retriever

[CatShelter] Adopting a cat
Whiskers meows: Meow!
Whiskers scratches!


================================================================================
                    POLYMORPHISM - QUICK REFERENCE
================================================================================

TYPES OF POLYMORPHISM:
----------------------
+----------------------+---------------------------+---------------------------+
| Type                 | Mechanism                 | Binding Time              |
+----------------------+---------------------------+---------------------------+
| Compile-time         | Method Overloading        | Compile time              |
| (Static)             | - Same name               | Based on reference type   |
|                      | - Different parameters    | and arguments             |
+----------------------+---------------------------+---------------------------+
| Runtime              | Method Overriding         | Runtime                   |
| (Dynamic)            | - Same name               | Based on actual object    |
|                      | - Same parameters         | type                      |
+----------------------+---------------------------+---------------------------+


UPCASTING VS DOWNCASTING:
-------------------------
+----------------------+---------------------------+---------------------------+
| Aspect               | Upcasting                 | Downcasting               |
+----------------------+---------------------------+---------------------------+
| Direction            | Child  Parent            | Parent  Child            |
| Syntax               | Parent p = child;         | Child c = (Child) parent; |
| Cast required        | No (automatic)            | Yes (explicit)            |
| Safety               | Always safe               | Can throw ClassCastEx     |
| Check needed         | No                        | Use instanceof            |
+----------------------+---------------------------+---------------------------+


================================================================================
                    POLYMORPHISM - QUICK REFERENCE (Continued)
================================================================================

KEY POINTS:
-----------
1. Parent reference can hold child object (upcasting)
2. Method called depends on actual object type, not reference type
3. Compile-time: Which method signature to call (based on arguments)
4. Runtime: Which method implementation to execute (based on object)
5. Cannot call child-specific methods using parent reference
6. Use instanceof before downcasting to avoid ClassCastException
7. Covariant return types allow returning subtype in overridden method


POLYMORPHISM RULES:
-------------------
+--------------------------------+----------------------------------------------+
| Rule                           | Example                                      |
+--------------------------------+----------------------------------------------+
| Parent ref = Child obj         | Animal a = new Dog();                       |
| Child ref = Parent obj         | Dog d = new Animal();  (won't compile)      |
| Call overridden method         | a.speak();  Dog's speak() executes          |
| Call child-only method         | a.fetch();  (won't compile)                 |
| Downcast with instanceof       | if (a instanceof Dog) { Dog d = (Dog)a; }    |
+--------------------------------+----------------------------------------------+


================================================================================
================================================================================
                    NEGATIVE SCENARIOS - POLYMORPHISM
================================================================================
================================================================================


--------------------------------------------------------------------------------
ERROR 1: Cannot Assign Parent Object to Child Reference
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal {
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barking");
    }
}

public class WrongAssignment {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = animal;    // ERROR! Cannot assign parent to child
    }
}

ERROR MESSAGE:
--------------
error: incompatible types: Animal cannot be converted to Dog
        Dog dog = animal;
                  ^

EXPLANATION:
------------
- Not every Animal is a Dog
- Animal object doesn't have Dog-specific features
- Compiler prevents this to avoid runtime issues

FIX:
----
class Animal {
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barking");
    }
}

public class CorrectAssignment {
    public static void main(String[] args) {
        // Option 1: Create Dog object directly
        Dog dog1 = new Dog();
        
        // Option 2: Create Dog, store in Animal, then downcast
        Animal animal = new Dog();    // Object is actually a Dog
        if (animal instanceof Dog) {
            Dog dog2 = (Dog) animal;  // Safe - object IS a Dog
            dog2.bark();
        }
        
        // Option 3: If you need Animal functionality, use Animal reference
        Animal animal2 = new Animal();
        animal2.eat();
    }
}


--------------------------------------------------------------------------------
ERROR 2: Calling Child-Specific Method on Parent Reference
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Vehicle {
    public void start() {
        System.out.println("Vehicle starting");
    }
}

class Car extends Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting with ignition");
    }
    
    public void openSunroof() {
        System.out.println("Opening sunroof");
    }
}

public class MethodCallError {
    public static void main(String[] args) {
        Vehicle vehicle = new Car();
        vehicle.start();        // OK - method exists in Vehicle
        vehicle.openSunroof();  // ERROR! Vehicle doesn't have openSunroof()
    }
}

ERROR MESSAGE:
--------------
error: cannot find symbol
        vehicle.openSunroof();
               ^
  symbol:   method openSunroof()
  location: variable vehicle of type Vehicle

EXPLANATION:
------------
- Compiler checks method existence based on REFERENCE TYPE (Vehicle)
- Vehicle class doesn't have openSunroof() method
- Even though actual object is Car, compiler doesn't know that

FIX:
----
public class MethodCallFixed {
    public static void main(String[] args) {
        Vehicle vehicle = new Car();
        vehicle.start();    // OK - calls Car's start() due to polymorphism
        
        // Option 1: Downcast to access child-specific method
        if (vehicle instanceof Car) {
            Car car = (Car) vehicle;
            car.openSunroof();
        }
        
        // Option 2: Use child reference from start
        Car car2 = new Car();
        car2.start();
        car2.openSunroof();    // OK - Car reference can access Car methods
        
        // Option 3: Inline downcast (if you're sure about the type)
        ((Car) vehicle).openSunroof();
    }
}


--------------------------------------------------------------------------------
ERROR 3: ClassCastException at Runtime
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal { }
class Dog extends Animal { }
class Cat extends Animal { }

public class ClassCastError {
    public static void main(String[] args) {
        Animal animal = new Cat();    // Actual object is Cat
        Dog dog = (Dog) animal;       // Trying to cast Cat to Dog - RUNTIME ERROR!
    }
}

ERROR MESSAGE (Runtime):
------------------------
Exception in thread "main" java.lang.ClassCastException: 
    Cat cannot be cast to Dog
    at ClassCastError.main(ClassCastError.java:8)

EXPLANATION:
------------
- Compiler allows the cast (both Cat and Dog extend Animal)
- At runtime, JVM checks actual object type
- Cat IS-NOT-A Dog, so cast fails

FIX:
----
class Animal { 
    public void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal { 
    public void bark() {
        System.out.println("Woof!");
    }
}

class Cat extends Animal { 
    public void meow() {
        System.out.println("Meow!");
    }
}

public class ClassCastFixed {
    public static void main(String[] args) {
        Animal animal = new Cat();
        
        // Always check with instanceof before downcasting
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.bark();
        } else if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.meow();
        } else {
            animal.makeSound();
        }
        
        // Better approach - process based on actual type
        processAnimal(new Dog());
        processAnimal(new Cat());
        processAnimal(new Animal());
    }
    
    public static void processAnimal(Animal animal) {
        animal.makeSound();    // Polymorphic call - always safe
        
        if (animal instanceof Dog) {
            ((Dog) animal).bark();
        } else if (animal instanceof Cat) {
            ((Cat) animal).meow();
        }
    }
}


--------------------------------------------------------------------------------
ERROR 4: Overloading Confused with Overriding
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Parent {
    public void display(int x) {
        System.out.println("Parent: " + x);
    }
}

class Child extends Parent {
    // This is OVERLOADING, not OVERRIDING!
    // Different parameter type
    public void display(String x) {
        System.out.println("Child: " + x);
    }
}

public class OverloadVsOverride {
    public static void main(String[] args) {
        Parent p = new Child();
        p.display(10);       // Calls Parent's display(int)
        p.display("Hello");  // ERROR! Parent doesn't have display(String)
    }
}

ERROR MESSAGE:
--------------
error: incompatible types: String cannot be converted to int
        p.display("Hello");
                  ^

EXPLANATION:
------------
- Child's display(String) is a NEW method (overloading)
- It's NOT overriding Parent's display(int)
- Parent reference can only see Parent's methods

FIX:
----
class Parent {
    public void display(int x) {
        System.out.println("Parent int: " + x);
    }
    
    public void display(String x) {
        System.out.println("Parent String: " + x);
    }
}

class Child extends Parent {
    // TRUE OVERRIDE - same signature
    @Override
    public void display(int x) {
        System.out.println("Child int: " + x);
    }
    
    @Override
    public void display(String x) {
        System.out.println("Child String: " + x);
    }
}

public class OverloadVsOverrideFixed {
    public static void main(String[] args) {
        Parent p = new Child();
        p.display(10);       // Calls Child's display(int)
        p.display("Hello");  // Calls Child's display(String)
    }
}

OUTPUT:
-------
Child int: 10
Child String: Hello


--------------------------------------------------------------------------------
ERROR 5: Static Methods Don't Exhibit Runtime Polymorphism
--------------------------------------------------------------------------------

PROBLEMATIC CODE (Misconception):
---------------------------------
class Parent {
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
    
    public void instanceMethod() {
        System.out.println("Parent instance method");
    }
}

class Child extends Parent {
    public static void staticMethod() {
        System.out.println("Child static method");
    }
    
    @Override
    public void instanceMethod() {
        System.out.println("Child instance method");
    }
}

public class StaticPolymorphismMisconception {
    public static void main(String[] args) {
        Parent p = new Child();
        
        p.staticMethod();    // Prints "Parent static method" - NOT polymorphic!
        p.instanceMethod();  // Prints "Child instance method" - IS polymorphic
    }
}

OUTPUT (Unexpected for beginners):
----------------------------------
Parent static method
Child instance method

EXPLANATION:
------------
- Static methods are resolved at COMPILE TIME based on reference type
- Instance methods are resolved at RUNTIME based on object type
- Static methods are HIDDEN, not overridden

FIX/BEST PRACTICE:
------------------
class Parent {
    public static void staticMethod() {
        System.out.println("Parent static method");
    }
    
    public void instanceMethod() {
        System.out.println("Parent instance method");
    }
}

class Child extends Parent {
    public static void staticMethod() {
        System.out.println("Child static method");
    }
    
    @Override
    public void instanceMethod() {
        System.out.println("Child instance method");
    }
}

public class StaticMethodBestPractice {
    public static void main(String[] args) {
        // Best Practice: Call static methods using class name
        Parent.staticMethod();    // Clear: Parent's method
        Child.staticMethod();     // Clear: Child's method
        
        // For polymorphism, use instance methods
        Parent p = new Child();
        p.instanceMethod();       // Polymorphic: Child's method
    }
}


--------------------------------------------------------------------------------
ERROR 6: Covariant Return Type - Wrong Direction
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Dog { }
class Animal { }    // Note: Dog doesn't extend Animal here (mistake)

class Parent {
    public Dog getAnimal() {
        return new Dog();
    }
}

class Child extends Parent {
    @Override
    public Animal getAnimal() {    // ERROR! Animal is not subtype of Dog
        return new Animal();
    }
}

ERROR MESSAGE:
--------------
error: getAnimal() in Child cannot override getAnimal() in Parent
    public Animal getAnimal() {
                  ^
  return type Animal is not compatible with Dog

CORRECT UNDERSTANDING:
----------------------
class Animal { }
class Dog extends Animal { }    // Dog IS-A Animal

class Parent {
    public Animal getAnimal() {    // Returns Animal
        return new Animal();
    }
}

class Child extends Parent {
    @Override
    public Dog getAnimal() {       // Returns Dog - OK! Dog IS-A Animal
        return new Dog();          // Covariant return type
    }
}

RULE:
-----
Covariant return type must be SAME or MORE SPECIFIC (subtype), not less specific.

Parent returns: Animal
Child can return: Animal, Dog, Cat (any subtype of Animal)
Child CANNOT return: Object (supertype of Animal)


--------------------------------------------------------------------------------
ERROR 7: Polymorphic Array - ArrayStoreException
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal { }
class Dog extends Animal { }
class Cat extends Animal { }

public class ArrayStoreError {
    public static void main(String[] args) {
        Dog[] dogs = new Dog[3];
        dogs[0] = new Dog();
        
        // Array covariance allows this assignment
        Animal[] animals = dogs;    // dogs array assigned to Animal[] reference
        
        // But storing Cat in Dog array causes runtime error!
        animals[1] = new Cat();     // RUNTIME ERROR!
    }
}

ERROR MESSAGE (Runtime):
------------------------
Exception in thread "main" java.lang.ArrayStoreException: Cat
    at ArrayStoreError.main(ArrayStoreError.java:13)

EXPLANATION:
------------
- Java arrays are covariant (Dog[] can be assigned to Animal[])
- But the actual array is still Dog[]
- Storing Cat in Dog[] fails at runtime

FIX:
----
import java.util.ArrayList;
import java.util.List;

class Animal { }
class Dog extends Animal { }
class Cat extends Animal { }

public class ArrayStoreFixed {
    public static void main(String[] args) {
        // Option 1: Create array of the correct base type
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();    // OK
        animals[1] = new Cat();    // OK
        animals[2] = new Animal(); // OK
        
        // Option 2: Keep arrays of specific types separate
        Dog[] dogs = new Dog[2];
        dogs[0] = new Dog();
        dogs[1] = new Dog();
        
        Cat[] cats = new Cat[2];
        cats[0] = new Cat();
        cats[1] = new Cat();
        
        // Option 3: Use generics with Collections (type-safe)
        List<Animal> animalList = new ArrayList<>();
        animalList.add(new Dog());
        animalList.add(new Cat());
        
        // This won't compile - generics are invariant (safer)
        // List<Animal> list = new ArrayList<Dog>();  // Compile error!
    }
}


--------------------------------------------------------------------------------
ERROR 8: Null Reference with instanceof
--------------------------------------------------------------------------------

PROBLEMATIC CODE:
-----------------
class Animal { }
class Dog extends Animal { }

public class NullInstanceof {
    public static void main(String[] args) {
        Animal animal = null;
        
        // This doesn't throw NullPointerException
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            System.out.println("It's a dog!");
        } else {
            System.out.println("Not a dog or null");
        }
        
        // But this would throw NullPointerException
        // animal.toString();    // NPE!
    }
}

OUTPUT:
-------
Not a dog or null

EXPLANATION:
------------
- instanceof returns FALSE for null (doesn't throw exception)
- This is actually SAFE behavior
- But be aware when processing results

BEST PRACTICE:
--------------
class Animal {
    public void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Dog barks");
    }
    
    public void fetch() {
        System.out.println("Dog fetches");
    }
}

public class NullSafePolymorphism {
    public static void main(String[] args) {
        processAnimal(new Dog());
        processAnimal(new Animal());
        processAnimal(null);
    }
    
    public static void processAnimal(Animal animal) {
        // Check for null first
        if (animal == null) {
            System.out.println("Animal is null, cannot process");
            return;
        }
        
        // Now safe to use
        animal.speak();    // Polymorphic call
        
        // Safe downcast
        if (animal instanceof Dog) {
            ((Dog) animal).fetch();
        }
    }
}

OUTPUT:
-------
Dog barks
Dog fetches
Animal speaks
Animal is null, cannot process


================================================================================
                    PRACTICE EXERCISES - POLYMORPHISM
================================================================================

EXERCISE 1: Shape Calculator
----------------------------
Create:
- Shape (base): abstract getArea(), abstract getPerimeter()
- Circle: radius, implement methods
- Rectangle: length, width, implement methods
- Triangle: base, height, sides, implement methods
- ShapeCalculator: calculates total area of Shape array

EXERCISE 2: Employee Payroll
----------------------------
Create:
- Employee (base): name, id, calculateSalary()
- FullTimeEmployee: monthlySalary, override calculateSalary()
- PartTimeEmployee: hourlyRate, hoursWorked, override calculateSalary()
- Contractor: projectRate, override calculateSalary()
- PayrollProcessor: processes array of Employee, calculates total payroll

EXERCISE 3: Notification System
-------------------------------
Create:
- Notification (base): message, recipient, send()
- EmailNotification: emailAddress, subject, override send()
- SMSNotification: phoneNumber, override send()
- PushNotification: deviceToken, override send()
- NotificationService: sends array of Notification polymorphically


================================================================================
                    WHAT'S NEXT?
================================================================================

We've covered:
 Topic 10: Inheritance
 Topic 11: Polymorphism

Next topic:
 Topic 12: Abstraction (Abstract Classes and Interfaces)

Shall I continue with Abstract Classes and Interfaces?

Would you like me to continue with Topic 12: Abstraction (Abstract Classes and Interfaces)? This is a crucial topic that builds on inheritance and polymorphism, and is heavily used in automation frameworks!
